// Generated by CoffeeScript 1.12.5
(function() {
  var AdapterBase, CormoTypesObjectId, MongoDBAdapter, ObjectID, _, _buildGroupFields, _buildWhere, _buildWhereSingle, _convertValueToObjectID, _objectIdToString, async, error, mongodb, stream, types,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  try {
    mongodb = require('mongodb');
  } catch (error1) {
    error = error1;
    console.log('Install mongodb module to use this adapter');
    process.exit(1);
  }

  ObjectID = mongodb.ObjectID;

  CormoTypesObjectId = (function() {
    function CormoTypesObjectId() {}

    return CormoTypesObjectId;

  })();

  _ = require('lodash');

  AdapterBase = require('./base');

  async = require('async');

  stream = require('stream');

  types = require('../types');

  _convertValueToObjectID = function(value, key) {
    var e;
    if (value == null) {
      return null;
    }
    try {
      return new ObjectID(value);
    } catch (error1) {
      e = error1;
      throw new Error("'" + key + "' is not a valid id");
    }
  };

  _objectIdToString = function(oid) {
    return oid.toString();
  };

  _buildWhereSingle = function(property, key, value, not_op) {
    var is_objectid, keys, property_type_class, sub_key, sub_value;
    if (key !== 'id' && (property == null)) {
      throw new Error("unknown column '" + key + "'");
    }
    property_type_class = property != null ? property.type_class : void 0;
    is_objectid = key === 'id' || property_type_class === CormoTypesObjectId;
    if (Array.isArray(value)) {
      if (is_objectid) {
        value = value.map(function(v) {
          return _convertValueToObjectID(v, key);
        });
      }
      if (not_op) {
        value = {
          $nin: value
        };
      } else {
        value = {
          $in: value
        };
      }
    } else if (typeof value === 'object' && value !== null && (keys = Object.keys(value)).length === 1) {
      sub_key = keys[0];
      switch (sub_key) {
        case '$not':
          return _buildWhereSingle(property, key, value[sub_key], !not_op);
        case '$gt':
        case '$lt':
        case '$gte':
        case '$lte':
          sub_value = value[sub_key];
          if (is_objectid) {
            sub_value = _convertValueToObjectID(sub_value, key);
          } else if (property_type_class === types.Date) {
            sub_value = new Date(sub_value);
          }
          value = _.zipObject([sub_key], [sub_value]);
          if (not_op) {
            value = {
              $not: value
            };
          }
          if (key === 'id') {
            key = '_id';
          }
          return _.zipObject([key], [value]);
        case '$contains':
          if (Array.isArray(value[sub_key])) {
            value = value[sub_key].map(function(v) {
              return new RegExp(v, 'i');
            });
            if (not_op) {
              value = {
                $nin: value
              };
              not_op = false;
            } else {
              value = {
                $in: value
              };
            }
          } else {
            value = new RegExp(value[sub_key], 'i');
          }
          break;
        case '$startswith':
          value = new RegExp('^' + value[sub_key], 'i');
          break;
        case '$endswith':
          value = new RegExp(value[sub_key] + '$', 'i');
          break;
        case '$in':
          if (is_objectid) {
            value[sub_key] = value[sub_key].map(function(v) {
              return _convertValueToObjectID(v, key);
            });
          }
          break;
        default:
          throw new Error("unknown operator '" + sub_key + "'");
      }
      if (not_op) {
        value = {
          $not: value
        };
      }
    } else if (_.isRegExp(value)) {
      if (!value.ignoreCase) {
        value = new RegExp(value.source, 'i');
      }
    } else {
      if (is_objectid) {
        value = _convertValueToObjectID(value, key);
      }
      if (not_op) {
        value = {
          $ne: value
        };
      }
    }
    if (key === 'id') {
      key = '_id';
    }
    if (property_type_class === types.Date) {
      value = new Date(value);
    }
    return _.zipObject([key], [value]);
  };

  _buildWhere = function(schema, conditions, conjunction) {
    var after_count, before_count, key, keys, obj, subs;
    if (conjunction == null) {
      conjunction = '$and';
    }
    if (Array.isArray(conditions)) {
      subs = conditions.map(function(condition) {
        return _buildWhere(schema, condition);
      });
    } else if (typeof conditions === 'object') {
      keys = Object.keys(conditions);
      if (keys.length === 0) {
        return;
      } else if (keys.length === 1) {
        key = keys[0];
        if (key.substr(0, 1) === '$') {
          switch (key) {
            case '$and':
              return _buildWhere(schema, conditions[key], '$and');
            case '$or':
              return _buildWhere(schema, conditions[key], '$or');
          }
          return;
        } else {
          return _buildWhereSingle(schema[key], key, conditions[key]);
        }
      } else {
        subs = keys.map(function(key) {
          return _buildWhereSingle(schema[key], key, conditions[key]);
        });
      }
    } else {
      throw new Error("'" + (JSON.stringify(conditions)) + "' is not an object");
    }
    if (subs.length === 0) {

    } else if (subs.length === 1) {
      return subs[0];
    } else {
      if (conjunction === '$and') {
        before_count = _.reduce(subs, (function(memo, sub) {
          return memo + Object.keys(sub).length;
        }), 0);
        subs.unshift({});
        obj = _.extend.apply(_, subs);
        subs.shift();
        keys = Object.keys(obj);
        after_count = keys.length;
        if (before_count === after_count && !_.some(keys, function(key) {
          return key.substr(0, 1) === '$';
        })) {
          return obj;
        }
      }
      return _.zipObject([conjunction], [subs]);
    }
  };

  _buildGroupFields = function(group_by, group_fields) {
    var expr, field, group;
    group = {};
    if (group_by) {
      if (group_by.length === 1) {
        group._id = '$' + group_by[0];
      } else {
        group._id = {};
        group_by.forEach(function(field) {
          return group._id[field] = '$' + field;
        });
      }
    } else {
      group._id = null;
    }
    for (field in group_fields) {
      expr = group_fields[field];
      group[field] = expr;
    }
    return group;
  };

  MongoDBAdapter = (function(superClass) {
    var _getMongoDBColName, _processSaveError;

    extend(MongoDBAdapter, superClass);

    MongoDBAdapter.prototype.key_type = types.String;

    MongoDBAdapter.prototype.key_type_internal = CormoTypesObjectId;

    MongoDBAdapter.prototype.support_geopoint = true;

    MongoDBAdapter.prototype.support_nested = true;

    function MongoDBAdapter(connection) {
      this._connection = connection;
      this._collections = {};
    }

    _getMongoDBColName = function(name) {
      if (name === '_archives') {
        return '@archives';
      } else {
        return name;
      }
    };

    MongoDBAdapter.prototype._collection = function(model) {
      var name;
      name = this._connection.models[model].tableName;
      if (!this._collections[name]) {
        return this._collections[name] = this._client.collection(_getMongoDBColName(name));
      } else {
        return this._collections[name];
      }
    };

    MongoDBAdapter.prototype._getTables = function(callback) {
      return this._client.listCollections().toArray(function(error, collections) {
        var tables;
        if (error) {
          return callback(error);
        }
        tables = collections.map(function(collection) {
          return collection.name;
        });
        return callback(null, tables);
      });
    };

    MongoDBAdapter.prototype._getSchema = function(table, callback) {
      return callback(null, 'NO SCHEMA');
    };

    MongoDBAdapter.prototype._getIndexes = function(table, callback) {
      return this._client.collection(table).listIndexes().toArray(function(error, rows) {
        var indexes, j, len, row;
        if (error) {
          return callback(error);
        }
        indexes = {};
        for (j = 0, len = rows.length; j < len; j++) {
          row = rows[j];
          indexes[row.name] = row.key;
        }
        return callback(null, indexes);
      });
    };

    MongoDBAdapter.prototype.getSchemas = function(callback) {
      return async.auto({
        get_tables: (function(_this) {
          return function(callback) {
            return _this._getTables(callback);
          };
        })(this),
        get_table_schemas: [
          'get_tables', (function(_this) {
            return function(results, callback) {
              var table_schemas;
              table_schemas = {};
              return async.each(results.get_tables, function(table, callback) {
                return _this._getSchema(table, function(error, schema) {
                  if (error) {
                    return callback(error);
                  }
                  table_schemas[table] = schema;
                  return callback(null);
                });
              }, function(error) {
                if (error) {
                  return callback(error);
                }
                return callback(null, table_schemas);
              });
            };
          })(this)
        ],
        get_indexes: [
          'get_tables', (function(_this) {
            return function(results, callback) {
              var all_indexes;
              all_indexes = {};
              return async.each(results.get_tables, function(table, callback) {
                return _this._getIndexes(table, function(error, indexes) {
                  if (error) {
                    return callback(error);
                  }
                  all_indexes[table] = indexes;
                  return callback(null);
                });
              }, function(error) {
                if (error) {
                  return callback(error);
                }
                return callback(null, all_indexes);
              });
            };
          })(this)
        ]
      }, function(error, results) {
        return callback(error, {
          tables: results.get_table_schemas,
          indexes: results.get_indexes
        });
      });
    };

    MongoDBAdapter.prototype.createTable = function(model, callback) {
      var collection, column, indexes, property, ref;
      collection = this._collection(model);
      indexes = [];
      ref = this._connection.models[model]._schema;
      for (column in ref) {
        property = ref[column];
        if (property.type_class === types.GeoPoint) {
          indexes.push([_.zipObject([column], ['2d'])]);
        }
      }
      return async.forEach(indexes, function(index, callback) {
        return collection.ensureIndex(index[0], index[1], function(error) {
          return callback(error);
        });
      }, function(error) {
        return callback(error);
      });
    };

    MongoDBAdapter.prototype.createIndex = function(model, index, callback) {
      var collection, options;
      collection = this._collection(model);
      options = {
        name: index.options.name,
        unique: index.options.unique
      };
      if (index.options.unique && !index.options.required) {
        options.sparse = true;
      }
      return collection.ensureIndex(index.columns, options, function(error) {
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    MongoDBAdapter.prototype.drop = function(model, callback) {
      var name;
      name = this._connection.models[model].tableName;
      delete this._collections[name];
      return this._client.dropCollection(_getMongoDBColName(name), function(error) {
        if (error && error.errmsg !== 'ns not found') {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    MongoDBAdapter.prototype.idToDB = function(value) {
      return _convertValueToObjectID(value, 'id');
    };

    MongoDBAdapter.prototype.valueToDB = function(value, column, property) {
      if (value == null) {
        return;
      }
      if (column === 'id' || property.type_class === CormoTypesObjectId) {
        if (property.array) {
          return value.map(function(v) {
            return v && _convertValueToObjectID(v, column);
          });
        } else {
          return _convertValueToObjectID(value, column);
        }
      }
      return value;
    };

    MongoDBAdapter.prototype._getModelID = function(data) {
      return _objectIdToString(data._id);
    };

    MongoDBAdapter.prototype.valueToModel = function(value, property) {
      if (property.type_class === CormoTypesObjectId) {
        if (property.array) {
          return value.map(function(v) {
            return v && _objectIdToString(v);
          });
        } else {
          return value && _objectIdToString(value);
        }
      } else {
        return value;
      }
    };

    _processSaveError = function(error, callback) {
      var key, ref;
      if ((ref = error != null ? error.code : void 0) === 11001 || ref === 11000) {
        key = error.message.match(/index: [\w-.]+\$(\w+)(_1)?/);
        error = new Error('duplicated ' + (key != null ? key[1] : void 0));
      } else {
        error = MongoDBAdapter.wrapError('unknown error', error);
      }
      return callback(error);
    };

    MongoDBAdapter.prototype.create = function(model, data, callback) {
      return this._collection(model).insert(data, {
        safe: true
      }, function(error, result) {
        var id;
        if (error) {
          return _processSaveError(error, callback);
        }
        id = _objectIdToString(result.ops[0]._id);
        if (id) {
          delete data._id;
          return callback(null, id);
        } else {
          return callback(new Error('unexpected result'));
        }
      });
    };

    MongoDBAdapter.prototype.createBulk = function(model, data, callback) {
      var chunks, i;
      if (data.length > 1000) {
        chunks = [];
        i = 0;
        while (i < data.length) {
          chunks.push(data.slice(i, i + 1000));
          i += 1000;
        }
        async.map(chunks, (function(_this) {
          return function(chunk, callback) {
            return _this.createBulk(model, chunk, callback);
          };
        })(this), function(error, records_list) {
          if (error) {
            return callback(error);
          }
          return callback(null, _.flatten(records_list));
        });
        return;
      }
      return this._collection(model).insert(data, {
        safe: true
      }, function(error, result) {
        var ids;
        if (error) {
          return _processSaveError(error, callback);
        }
        error = void 0;
        ids = result.ops.map(function(doc) {
          var id;
          id = _objectIdToString(doc._id);
          if (id) {
            delete data._id;
          } else {
            error = new Error('unexpected result');
          }
          return id;
        });
        if (error) {
          return callback(error);
        }
        return callback(null, ids);
      });
    };

    MongoDBAdapter.prototype.update = function(model, data, callback) {
      var id;
      id = data.id;
      delete data.id;
      return this._collection(model).update({
        _id: id
      }, data, {
        safe: true
      }, function(error) {
        if (error) {
          return _processSaveError(error, callback);
        }
        return callback(null);
      });
    };

    MongoDBAdapter.prototype._buildUpdateOps = function(schema, update_ops, data, path, object) {
      var column, property, results1, value;
      results1 = [];
      for (column in object) {
        value = object[column];
        property = schema[path + column];
        if (property) {
          if (value != null) {
            if (value.$inc != null) {
              results1.push(update_ops.$inc[path + column] = value.$inc);
            } else {
              results1.push(update_ops.$set[path + column] = value);
            }
          } else {
            results1.push(update_ops.$unset[path + column] = '');
          }
        } else if (typeof object[column] === 'object') {
          results1.push(this._buildUpdateOps(schema, update_ops, data, path + column + '.', object[column]));
        } else {
          results1.push(void 0);
        }
      }
      return results1;
    };

    MongoDBAdapter.prototype.updatePartial = function(model, data, conditions, options, callback) {
      var e, schema, update_ops;
      schema = this._connection.models[model]._schema;
      try {
        conditions = _buildWhere(schema, conditions);
      } catch (error1) {
        e = error1;
        return callback(e);
      }
      if (!conditions) {
        conditions = {};
      }
      update_ops = {
        $set: {},
        $unset: {},
        $inc: {}
      };
      this._buildUpdateOps(schema, update_ops, data, '', data);
      if (Object.keys(update_ops.$set).length === 0) {
        delete update_ops.$set;
      }
      if (Object.keys(update_ops.$unset).length === 0) {
        delete update_ops.$unset;
      }
      if (Object.keys(update_ops.$inc).length === 0) {
        delete update_ops.$inc;
      }
      return this._collection(model).update(conditions, update_ops, {
        safe: true,
        multi: true
      }, function(error, result) {
        if (error) {
          return _processSaveError(error, callback);
        }
        return callback(null, result.result.n);
      });
    };

    MongoDBAdapter.prototype.upsert = function(model, data, conditions, options, callback) {
      var e, key, schema, update_ops, value;
      schema = this._connection.models[model]._schema;
      try {
        conditions = _buildWhere(schema, conditions);
      } catch (error1) {
        e = error1;
        return callback(e);
      }
      if (!conditions) {
        conditions = {};
      }
      update_ops = {
        $set: {},
        $unset: {},
        $inc: {}
      };
      for (key in conditions) {
        value = conditions[key];
        update_ops.$set[key] = value;
      }
      this._buildUpdateOps(schema, update_ops, data, '', data);
      if (Object.keys(update_ops.$set).length === 0) {
        delete update_ops.$set;
      }
      if (Object.keys(update_ops.$unset).length === 0) {
        delete update_ops.$unset;
      }
      if (Object.keys(update_ops.$inc).length === 0) {
        delete update_ops.$inc;
      }
      return this._collection(model).update(conditions, update_ops, {
        safe: true,
        upsert: true
      }, function(error, result) {
        if (error) {
          return _processSaveError(error, callback);
        }
        return callback(null);
      });
    };

    MongoDBAdapter.prototype.findById = function(model, id, options, callback) {
      var client_options, e, fields;
      if (options.select) {
        fields = {};
        options.select.forEach(function(column) {
          return fields[column] = 1;
        });
      }
      try {
        id = _convertValueToObjectID(id, 'id');
      } catch (error1) {
        e = error1;
        return callback(new Error('not found'));
      }
      client_options = {};
      if (fields) {
        client_options.fields = fields;
      }
      if (options.explain) {
        client_options.explain = true;
        return this._collection(model).findOne({
          _id: id
        }, client_options, function(error, result) {
          if (error) {
            return callback(error);
          }
          return callback(null, result);
        });
      }
      return this._collection(model).findOne({
        _id: id
      }, client_options, (function(_this) {
        return function(error, result) {
          if (error) {
            return callback(MongoDBAdapter.wrapError('unknown error', error));
          }
          if (!result) {
            return callback(new Error('not found'));
          }
          return callback(null, _this._convertToModelInstance(model, result, options));
        };
      })(this));
    };

    MongoDBAdapter.prototype._buildConditionsForFind = function(model, conditions, options) {
      var client_options, field, fields, keys, obj, orders;
      if (options.select) {
        fields = {};
        options.select.forEach(function(column) {
          return fields[column] = 1;
        });
      }
      conditions = _buildWhere(this._connection.models[model]._schema, conditions);
      if ((options.near != null) && (field = Object.keys(options.near)[0])) {
        if (conditions) {
          keys = Object.keys(conditions);
        }
        if (keys && (keys.length > 1 || keys[0].substr(0, 1) !== '$')) {
          conditions[field] = {
            $near: options.near[field]
          };
        } else {
          obj = {};
          obj[field] = {
            $near: options.near[field]
          };
          if (conditions) {
            conditions = {
              $and: [conditions, obj]
            };
          } else {
            conditions = obj;
          }
        }
      }
      if (options.orders.length > 0) {
        orders = {};
        options.orders.forEach(function(order) {
          var column, dir;
          if (order[0] === '-') {
            column = order.slice(1);
            dir = -1;
          } else {
            column = order;
            dir = 1;
          }
          if (options.group_by) {
            if (options.group_by.length === 1) {
              if (column === options.group_by[0]) {
                column = '_id';
              }
            } else {
              if (options.group_by.indexOf(column) >= 0) {
                column = '_id.' + column;
              }
            }
          } else {
            if (column === 'id') {
              column = '_id';
            }
          }
          return orders[column] = dir;
        });
      }
      client_options = {
        limit: options.limit,
        skip: options.skip
      };
      if (fields) {
        client_options.fields = fields;
      }
      if (orders) {
        client_options.sort = orders;
      }
      return [conditions, fields, orders, client_options];
    };

    MongoDBAdapter.prototype.find = function(model, conditions, options, callback) {
      var client_options, e, fields, orders, pipeline, ref;
      try {
        ref = this._buildConditionsForFind(model, conditions, options), conditions = ref[0], fields = ref[1], orders = ref[2], client_options = ref[3];
      } catch (error1) {
        e = error1;
        return callback(e);
      }
      if (options.group_by || options.group_fields) {
        pipeline = [];
        if (conditions) {
          pipeline.push({
            $match: conditions
          });
        }
        pipeline.push({
          $group: _buildGroupFields(options.group_by, options.group_fields)
        });
        if (orders) {
          pipeline.push({
            $sort: orders
          });
        }
        if (options.conditions_of_group.length > 0) {
          pipeline.push({
            $match: _buildWhere(options.group_fields, options.conditions_of_group)
          });
        }
        if (options.limit) {
          pipeline.push({
            $limit: options.limit
          });
        }
        if (options.explain) {
          return this._collection(model).aggregate(pipeline, {
            explain: true
          }, function(error, result) {
            if (error) {
              return callback(error);
            }
            return callback(null, result);
          });
        }
        return this._collection(model).aggregate(pipeline, (function(_this) {
          return function(error, result) {
            if (error) {
              return callback(MongoDBAdapter.wrapError('unknown error', error));
            }
            return callback(null, result.map(function(record) {
              var group, j, len, ref1;
              if (options.group_by) {
                if (options.group_by.length === 1) {
                  record[options.group_by[0]] = record._id;
                } else {
                  ref1 = options.group_by;
                  for (j = 0, len = ref1.length; j < len; j++) {
                    group = ref1[j];
                    record[group] = record._id[group];
                  }
                }
              }
              return _this._convertToGroupInstance(model, record, options.group_by, options.group_fields);
            }));
          };
        })(this));
      } else {
        if (options.explain) {
          client_options.explain = true;
          return this._collection(model).find(conditions, client_options, function(error, cursor) {
            if (error) {
              return callback(error);
            }
            return cursor.toArray(function(error, result) {
              if (error) {
                return callback(error);
              }
              return callback(null, result);
            });
          });
        }
        return this._collection(model).find(conditions, client_options, (function(_this) {
          return function(error, cursor) {
            if (error || !cursor) {
              return callback(MongoDBAdapter.wrapError('unknown error', error));
            }
            return cursor.toArray(function(error, result) {
              if (error) {
                return callback(MongoDBAdapter.wrapError('unknown error', error));
              }
              return callback(null, result.map(function(record) {
                return _this._convertToModelInstance(model, record, options);
              }));
            });
          };
        })(this));
      }
    };

    MongoDBAdapter.prototype.stream = function(model, conditions, options) {
      var client_options, e, fields, orders, readable, ref, transformer;
      try {
        ref = this._buildConditionsForFind(model, conditions, options), conditions = ref[0], fields = ref[1], orders = ref[2], client_options = ref[3];
      } catch (error1) {
        e = error1;
        readable = new stream.Readable({
          objectMode: true
        });
        readable._read = function() {
          return readable.emit('error', e);
        };
        return readable;
      }
      transformer = new stream.Transform({
        objectMode: true
      });
      transformer._transform = (function(_this) {
        return function(record, encoding, callback) {
          transformer.push(_this._convertToModelInstance(model, record, options));
          return callback();
        };
      })(this);
      this._collection(model).find(conditions, client_options, function(error, cursor) {
        if (error || !cursor) {
          return transformer.emit('error', MongoDBAdapter.wrapError('unknown error', error));
        }
        return cursor.on('error', function(error) {
          return transformer.emit('error', error);
        }).pipe(transformer);
      });
      return transformer;
    };

    MongoDBAdapter.prototype.count = function(model, conditions, options, callback) {
      var e, pipeline;
      try {
        conditions = _buildWhere(this._connection.models[model]._schema, conditions);
      } catch (error1) {
        e = error1;
        return callback(e);
      }
      if (options.group_by || options.group_fields) {
        pipeline = [];
        if (conditions) {
          pipeline.push({
            $match: conditions
          });
        }
        pipeline.push({
          $group: _buildGroupFields(options.group_by, options.group_fields)
        });
        if (options.conditions_of_group.length > 0) {
          pipeline.push({
            $match: _buildWhere(options.group_fields, options.conditions_of_group)
          });
        }
        pipeline.push({
          $group: {
            _id: null,
            count: {
              $sum: 1
            }
          }
        });
        return this._collection(model).aggregate(pipeline, (function(_this) {
          return function(error, result) {
            if (error) {
              return callback(MongoDBAdapter.wrapError('unknown error', error));
            }
            if ((result != null ? result.length : void 0) !== 1) {
              return callback(new Error('unknown error'));
            }
            return callback(null, result[0].count);
          };
        })(this));
      } else {
        return this._collection(model).count(conditions, (function(_this) {
          return function(error, count) {
            if (error) {
              return callback(MongoDBAdapter.wrapError('unknown error', error));
            }
            return callback(null, count);
          };
        })(this));
      }
    };

    MongoDBAdapter.prototype["delete"] = function(model, conditions, callback) {
      var e, model_class;
      model_class = this._connection.models[model];
      try {
        conditions = _buildWhere(model_class._schema, conditions);
      } catch (error1) {
        e = error1;
        return callback(e);
      }
      return this._collection(model).remove(conditions, {
        safe: true
      }, function(error, result) {
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null, result.result.n);
      });
    };

    MongoDBAdapter.prototype.connect = function(settings, callback) {
      var url;
      if (settings.user || settings.password) {
        url = "mongodb://" + settings.user + ":" + settings.password + "@" + (settings.host || 'localhost') + ":" + (settings.port || 27017) + "/" + settings.database;
      } else {
        url = "mongodb://" + (settings.host || 'localhost') + ":" + (settings.port || 27017) + "/" + settings.database;
      }
      return mongodb.MongoClient.connect(url, (function(_this) {
        return function(error, db) {
          if (error) {
            return callback(MongoDBAdapter.wrapError('unknown error', error));
          }
          _this._client = db;
          return callback(null);
        };
      })(this));
    };

    MongoDBAdapter.prototype.close = function() {
      if (this._client) {
        this._client.close();
      }
      return this._client = null;
    };

    MongoDBAdapter.prototype.collection = function(model) {
      return this._collection(model);
    };

    return MongoDBAdapter;

  })(AdapterBase);

  module.exports = function(connection) {
    return new MongoDBAdapter(connection);
  };

}).call(this);

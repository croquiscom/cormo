// Generated by CoffeeScript 2.3.1
var AdapterBase, RedisAdapter, _, async, error, redis, tableize, types;

try {
  redis = require('redis');
} catch (error1) {
  error = error1;
  console.log('Install redis module to use this adapter');
  process.exit(1);
}

AdapterBase = require('./base');

types = require('../types');

tableize = require('../util/inflector').tableize;

async = require('async');

_ = require('lodash');

RedisAdapter = (function() {
  //#
  // Adapter for Redis
  // @namespace adapter
  class RedisAdapter extends AdapterBase {
    _getKeys(table, conditions, callback) {
      if (Array.isArray(conditions)) {
        if (conditions.length === 0) {
          this._client.keys(`${table}:*`, function(error, keys) {
            return callback(null, keys);
          });
          return;
        }
        async.map(conditions, (condition, callback) => {
          return this._getKeys(table, condition, callback);
        }, function(error, keys) {
          return callback(null, _.flatten(keys));
        });
        return;
      } else if (typeof conditions === 'object' && conditions.id) {
        if (conditions.id.$in) {
          callback(null, conditions.id.$in.map(function(id) {
            return `${table}:${id}`;
          }));
        } else {
          callback(null, [`${table}:${conditions.id}`]);
        }
        return;
      }
      return callback(null, []);
    }

    //#
    // Creates a Redis adapter
    constructor(connection) {
      super();
      this._connection = connection;
    }

    //# @override AdapterBase::drop
    drop(model) {
      return new Promise((resolve, reject) => {
        return this.delete(model, [], (error) => {
          if (error) {
            return reject(error);
          } else {
            return resolve();
          }
        });
      });
    }

    valueToDB(value, column, property) {
      if (value == null) {
        return;
      }
      switch (property.type_class) {
        case types.Number:
        case types.Integer:
          return value.toString();
        case types.Date:
          return new Date(value).getTime().toString();
        case types.Boolean:
          if (value) {
            return '1';
          } else {
            return '0';
          }
          break;
        case types.Object:
          return JSON.stringify(value);
        default:
          return value;
      }
    }

    valueToModel(value, property) {
      switch (property.type_class) {
        case types.Number:
        case types.Integer:
          return Number(value);
        case types.Date:
          return new Date(Number(value));
        case types.Boolean:
          return value !== '0';
        case types.Object:
          return JSON.parse(value);
        default:
          return value;
      }
    }

    //# @override AdapterBase::create
    create(model, data) {
      return new Promise((resolve, reject) => {
        data.$_$ = ''; // ensure that there is one argument(one field) at least
        return this._client.incr(`${tableize(model)}:_lastid`, (error, id) => {
          if (error) {
            reject(RedisAdapter.wrapError('unknown error', error));
            return;
          }
          return this._client.hmset(`${tableize(model)}:${id}`, data, function(error) {
            if (error) {
              return reject(RedisAdapter.wrapError('unknown error', error));
            } else {
              return resolve(id);
            }
          });
        });
      });
    }

    //# @override AdapterBase::createBulk
    createBulk(model, data) {
      return this._createBulkDefault(model, data);
    }

    //# @override AdapterBase::update
    update(model, data) {
      return new Promise((resolve, reject) => {
        var key;
        key = `${tableize(model)}:${data.id}`;
        delete data.id;
        data.$_$ = ''; // ensure that there is one argument(one field) at least
        return this._client.exists(key, (error, exists) => {
          if (error) {
            reject(RedisAdapter.wrapError('unknown error', error));
            return;
          }
          if (!exists) {
            resolve();
            return;
          }
          return this._client.del(key, (error) => {
            if (error) {
              reject(RedisAdapter.wrapError('unknown error', error));
              return;
            }
            return this._client.hmset(key, data, function(error) {
              if (error) {
                reject(RedisAdapter.wrapError('unknown error', error));
                return;
              }
              return resolve();
            });
          });
        });
      });
    }

    //# @override AdapterBase::updatePartial
    updatePartial(model, data, conditions, options) {
      return new Promise((resolve, reject) => {
        var fields_to_del, table;
        fields_to_del = Object.keys(data).filter(function(key) {
          return data[key] == null;
        });
        fields_to_del.forEach(function(key) {
          return delete data[key];
        });
        fields_to_del.push('$_$'); // ensure that there is one argument at least
        table = tableize(model);
        data.$_$ = ''; // ensure that there is one argument(one field) at least
        return this._getKeys(table, conditions, (error, keys) => {
          return async.forEach(keys, (key, callback) => {
            var args;
            args = _.clone(fields_to_del);
            args.unshift(key);
            return this._client.hdel(args, (error) => {
              if (error) {
                return callback(RedisAdapter.wrapError('unknown error', error));
              }
              return this._client.hmset(key, data, (error) => {
                if (error) {
                  return callback(RedisAdapter.wrapError('unknown error', error));
                }
                return callback(null);
              });
            });
          }, (error) => {
            return resolve(keys.length);
          });
        });
      });
    }

    //# @override AdapterBase::findById
    findById(model, id, options) {
      return new Promise((resolve, reject) => {
        return this._client.hgetall(`${tableize(model)}:${id}`, (error, result) => {
          if (error) {
            reject(RedisAdapter.wrapError('unknown error', error));
            return;
          }
          if (result) {
            result.id = id;
            return resolve(this._convertToModelInstance(model, result, options));
          } else {
            return reject(new Error('not found'));
          }
        });
      });
    }

    //# @override AdapterBase::find
    find(model, conditions, options) {
      return new Promise((resolve, reject) => {
        var table;
        table = tableize(model);
        return this._getKeys(table, conditions, (error, keys) => {
          return async.map(keys, (key, callback) => {
            return this._client.hgetall(key, function(error, result) {
              if (result) {
                result.id = Number(key.substr(table.length + 1));
              }
              return callback(null, result);
            });
          }, (error, records) => {
            records = records.filter(function(record) {
              return record != null;
            });
            return resolve(records.map((record) => {
              return this._convertToModelInstance(model, record, options);
            }));
          });
        });
      });
    }

    _delete(keys, callback) {}

    //# @override AdapterBase::delete
    delete(model, conditions, callback) {
      return this._getKeys(tableize(model), conditions, (error, keys) => {
        if (error) {
          return callback(error);
        }
        if (keys.length === 0) {
          return callback(null, 0);
        }
        return this._client.del(keys, function(error, count) {
          if (error) {
            return callback(RedisAdapter.wrapError('unknown error', error));
          }
          return callback(null, count);
        });
      });
    }

    //#
    // Connects to the database
    // @param {Object} settings
    // @param {String} [settings.host='127.0.0.1']
    // @param {Number} [settings.port=6379]
    // @param {Number} [settings.database=0]
    // @nodejscallback
    connect(settings, callback) {
      this._client = redis.createClient(settings.port || 6379, settings.host || '127.0.0.1');
      return this._client.on('connect', () => {
        return this._client.select(settings.database || 0, function(error) {
          return callback(error);
        });
      });
    }

  };

  RedisAdapter.prototype.support_upsert = false;

  RedisAdapter.prototype.key_type = types.Integer;

  return RedisAdapter;

}).call(this);

module.exports = function(connection) {
  return new RedisAdapter(connection);
};

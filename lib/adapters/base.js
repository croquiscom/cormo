// Generated by CoffeeScript 1.9.3
(function() {
  var AdapterBase, async, stream, types, util;

  async = require('async');

  stream = require('stream');

  types = require('../types');

  util = require('../util');

  AdapterBase = (function() {
    function AdapterBase() {}

    AdapterBase.prototype.support_fractional_seconds = true;

    AdapterBase.wrapError = function(msg, cause) {
      var error;
      error = new Error(msg);
      error.cause = cause;
      return error;
    };

    AdapterBase.prototype.getSchemas = function(callback) {
      return callback(null, {
        tables: []
      });
    };

    AdapterBase.prototype.createTable = function(model, callback) {
      return callback(null);
    };

    AdapterBase.prototype.addColumn = function(model, column_property, callback) {
      return callback(null);
    };

    AdapterBase.prototype.createIndex = function(model, index, callback) {
      return callback(null);
    };

    AdapterBase.prototype.createForeignKey = function(model, column, type, references, callback) {
      return callback(null);
    };

    AdapterBase.prototype.drop = function(model, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.idToDB = function(value) {
      return value;
    };

    AdapterBase.prototype.valueToDB = function(value, column, property) {
      if (property.type_class === types.Object || property.array) {
        return JSON.stringify(value);
      } else if (value != null) {
        return value;
      } else {
        return null;
      }
    };

    AdapterBase.prototype._getModelID = function(data) {
      return data.id;
    };

    AdapterBase.prototype.valueToModel = function(value, property) {
      if (property.type_class === types.Object || property.array) {
        return JSON.parse(value);
      } else {
        return value;
      }
    };

    AdapterBase.prototype.setValuesFromDB = function(instance, data, schema, selected_columns) {
      var column, i, len, parts, property, results, support_nested, value;
      if (!selected_columns) {
        selected_columns = Object.keys(schema);
      }
      support_nested = this.support_nested;
      results = [];
      for (i = 0, len = selected_columns.length; i < len; i++) {
        column = selected_columns[i];
        property = schema[column];
        parts = property._parts;
        value = support_nested ? util.getPropertyOfPath(data, parts) : data[property._dbname];
        if (value != null) {
          value = this.valueToModel(value, property);
        } else {
          value = null;
        }
        results.push(util.setPropertyOfPath(instance, parts, value));
      }
      return results;
    };

    AdapterBase.prototype._convertToModelInstance = function(model, data, options) {
      var id, instance, modelClass;
      if (options.lean) {
        model = this._connection.models[model];
        instance = {};
        this.setValuesFromDB(instance, data, model._schema, options.select);
        model._collapseNestedNulls(instance, options.select_raw, null);
        instance.id = this._getModelID(data);
        return instance;
      } else {
        id = this._getModelID(data);
        modelClass = this._connection.models[model];
        return new modelClass(data, id, options.select, options.select_raw);
      }
    };

    AdapterBase.prototype._convertToGroupInstance = function(model, data, group_by, group_fields) {
      var expr, field, i, instance, len, op, property, schema;
      instance = {};
      if (group_by) {
        schema = this._connection.models[model]._schema;
        for (i = 0, len = group_by.length; i < len; i++) {
          field = group_by[i];
          property = schema[field];
          if (property) {
            instance[field] = this.valueToModel(data[field], property);
          }
        }
      }
      for (field in group_fields) {
        expr = group_fields[field];
        op = Object.keys(expr)[0];
        if (op === '$sum' || op === '$max' || op === '$min') {
          instance[field] = Number(data[field]);
        }
      }
      return instance;
    };

    AdapterBase.prototype.create = function(model, data, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.createBulk = function(model, data, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype._createBulkDefault = function(model, data, callback) {
      return async.map(data, (function(_this) {
        return function(item, callback) {
          return _this.create(model, item, util.bindDomain(callback));
        };
      })(this), callback);
    };

    AdapterBase.prototype.update = function(model, data, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.updatePartial = function(model, data, conditions, options, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.upsert = function(model, data, conditions, options, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.findById = function(model, id, options, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.find = function(model, conditions, options, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.stream = function(model, conditions, options) {
      var readable;
      readable = new stream.Readable({
        objectMode: true
      });
      readable._read = function() {
        return readable.emit('error', new Error('not implemented'));
      };
      return readable;
    };

    AdapterBase.prototype.count = function(model, conditions, options, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype["delete"] = function(model, conditions, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.close = function() {};

    return AdapterBase;

  })();

  module.exports = AdapterBase;

  if (process.env.NODE_ENV === 'test') {
    AdapterBase.wrapError = function(msg, cause) {
      return new Error(msg + ' caused by ' + cause.toString());
    };
  }

}).call(this);

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// Generated by CoffeeScript 2.3.1
var AdapterBase, stream, types, util;
stream = require('stream');
types = require('../types');
util = require('../util');
AdapterBase = (function () {
    //#
    // Base class for adapters
    // @namespace adapter
    class AdapterBase {
        //#
        // Wraps adapter specific errors
        // @param {String} msg CORMO's error message
        // @param {Error} cause adapter specific error object
        static wrapError(msg, cause) {
            var error;
            error = new Error(msg);
            error.cause = cause;
            return error;
        }
        //#
        // Returns current schemas.
        // @abstract
        // @return {Object}
        // @returnprop {Object} tables
        // @promise
        // @see Connection::applySchemas
        getSchemas() {
            return Promise.resolve({
                tables: []
            });
        }
        //# Creates a table.
        // @abstract
        // @param {String} model
        // @promise
        // @see Connection::applySchemas
        createTable(model) {
            return Promise.resolve();
        }
        //# Adds a column to a table
        // @abstract
        // @param {String} model
        // @param {Object} column_property
        // @promise
        // @see Connection::applySchemas
        addColumn(model, column_property) {
            return Promise.resolve();
        }
        //# Creates an index.
        // @abstract
        // @param {String} model
        // @param {Object} index
        // @param {Object} index.columns
        // @param {Object} index.options
        // @param {String} index.options.name
        // @param {Boolean} index.options.unique
        // @promise
        // @see Connection::applySchemas
        createIndex(model, index) {
            return Promise.resolve();
        }
        //# Creates a foreign key.
        // @abstract
        // @param {String} model
        // @param {String} column
        // @param {String} type
        // @param {Class<Model>} references
        // @promise
        // @see Connection::applySchemas
        createForeignKey(model, column, type, references) {
            return Promise.resolve();
        }
        //#
        // Drops a model from the database
        // @abstract
        // @param {String} model
        // @promise
        // @see Model.drop
        drop(model) {
            return Promise.reject('not implemented');
        }
        idToDB(value) {
            return value;
        }
        valueToDB(value, column, property) {
            if (property.type_class === types.Object || property.array) {
                return JSON.stringify(value);
            }
            else if (value != null) {
                return value;
            }
            else {
                return null;
            }
        }
        _getModelID(data) {
            return data.id;
        }
        valueToModel(value, property) {
            if (property.type_class === types.Object || property.array) {
                return JSON.parse(value);
            }
            else {
                return value;
            }
        }
        setValuesFromDB(instance, data, schema, selected_columns) {
            var column, i, len, parts, property, results, support_nested, value;
            if (!selected_columns) {
                selected_columns = Object.keys(schema);
            }
            support_nested = this.support_nested;
            results = [];
            for (i = 0, len = selected_columns.length; i < len; i++) {
                column = selected_columns[i];
                property = schema[column];
                parts = property._parts;
                value = support_nested ? util.getPropertyOfPath(data, parts) : data[property._dbname];
                if (value != null) {
                    value = this.valueToModel(value, property);
                }
                else {
                    value = null;
                }
                results.push(util.setPropertyOfPath(instance, parts, value));
            }
            return results;
        }
        _convertToModelInstance(model, data, options) {
            var id, instance, modelClass;
            if (options.lean) {
                model = this._connection.models[model];
                instance = {};
                this.setValuesFromDB(instance, data, model._schema, options.select);
                model._collapseNestedNulls(instance, options.select_raw, null);
                instance.id = this._getModelID(data);
                return instance;
            }
            else {
                id = this._getModelID(data);
                modelClass = this._connection.models[model];
                return new modelClass(data, id, options.select, options.select_raw);
            }
        }
        _convertToGroupInstance(model, data, group_by, group_fields) {
            var expr, field, i, instance, len, op, property, schema;
            instance = {};
            if (group_by) {
                schema = this._connection.models[model]._schema;
                for (i = 0, len = group_by.length; i < len; i++) {
                    field = group_by[i];
                    property = schema[field];
                    if (property) {
                        instance[field] = this.valueToModel(data[field], property);
                    }
                }
            }
            for (field in group_fields) {
                expr = group_fields[field];
                op = Object.keys(expr)[0];
                if (op === '$sum' || op === '$max' || op === '$min') {
                    instance[field] = Number(data[field]);
                }
            }
            return instance;
        }
        //#
        // Creates a record
        // @abstract
        // @param {String} model
        // @param {Object} data
        // @return {RecordID}
        // @promise
        create(model, data) {
            return Promise.reject(new Error('not implemented'));
        }
        //#
        // Creates records
        // @abstract
        // @param {String} model
        // @param {Array<Object>} data
        // @return {Array<RecordID>}
        // @promise
        createBulk(model, data) {
            return Promise.reject(new Error('not implemented'));
        }
        _createBulkDefault(model, data) {
            return __awaiter(this, void 0, void 0, function* () {
                return (yield Promise.all(data.map((item) => {
                    return this.create(model, item);
                })));
            });
        }
        //#
        // Updates a record
        // @abstract
        // @param {String} model
        // @param {Object} data
        // @promise
        update(model, data) {
            return Promise.reject(new Error('not implemented'));
        }
        //#
        // Updates some fields of records that match conditions
        // @abstract
        // @param {String} model
        // @param {Object} data
        // @param {Object} conditions
        // @param {Object} options
        // @promise
        updatePartial(model, data, conditions, options) {
            return Promise.reject(new Error('not implemented'));
        }
        //#
        // Updates some fields of records that match conditions or inserts a new record
        // @abstract
        // @param {String} model
        // @param {Object} data
        // @param {Object} conditions
        // @param {Object} options
        // @promise
        upsert(model, data, conditions, options) {
            return Promise.reject(new Error('not implemented'));
        }
        //#
        // Finds a record by id
        // @abstract
        // @param {String} model
        // @param {RecordID} id
        // @param {Object} options
        // @return {Model}
        // @promise
        // @throws {Error('not found')}
        // @see Query::exec
        findById(model, id, options) {
            return Promise.reject(new Error('not implemented'));
        }
        //#
        // Finds records
        // @abstract
        // @param {String} model
        // @param {Object} conditions
        // @param {Object} options
        // @return {Array<Model>}
        // @promise
        // @see Query::exec
        find(model, conditions, options) {
            return Promise.reject(new Error('not implemented'));
        }
        //#
        // Streams matching records
        // @abstract
        // @param {String} model
        // @param {Object} conditions
        // @param {Object} options
        // @return {Readable}
        // @see Query::stream
        stream(model, conditions, options) {
            var readable;
            readable = new stream.Readable({
                objectMode: true
            });
            readable._read = function () {
                return readable.emit('error', new Error('not implemented'));
            };
            return readable;
        }
        //#
        // Counts records
        // @abstract
        // @param {String} model
        // @param {Object} conditions
        // @param {Object} options
        // @return {Number}
        // @promise
        // @see Query::count
        count(model, conditions, options) {
            return Promise.reject(new Error('not implemented'));
        }
        //#
        // Deletes records from the database
        // @abstract
        // @param {String} model
        // @param {Object} conditions
        // @return {Number}
        // @promise
        // @see Query::delete
        delete(model, conditions) {
            return Promise.reject(new Error('not implemented'));
        }
        //#
        // Closes connection
        close() { }
    }
    ;
    AdapterBase.prototype.support_fractional_seconds = true;
    AdapterBase.prototype.support_upsert = true;
    return AdapterBase;
}).call(this);
module.exports = AdapterBase;
if (process.env.NODE_ENV === 'test') {
    AdapterBase.wrapError = function (msg, cause) {
        return new Error(msg + ' caused by ' + cause.toString());
    };
}

// Generated by CoffeeScript 2.3.1
var AdapterBase, stream, types, util;

stream = require('stream');

types = require('../types');

util = require('../util');

AdapterBase = (function() {
  //#
  // Base class for adapters
  // @namespace adapter
  class AdapterBase {
    //#
    // Wraps adapter specific errors
    // @param {String} msg CORMO's error message
    // @param {Error} cause adapter specific error object
    static wrapError(msg, cause) {
      var error;
      error = new Error(msg);
      error.cause = cause;
      return error;
    }

    //#
    // Returns current schemas.
    // @abstract
    // @return {Object}
    // @returnprop {Object} tables
    // @promise
    // @see Connection::applySchemas
    getSchemas() {
      return Promise.resolve({
        tables: []
      });
    }

    //# Creates a table.
    // @abstract
    // @param {String} model
    // @promise
    // @see Connection::applySchemas
    createTable(model) {
      return Promise.resolve();
    }

    //# Adds a column to a table
    // @abstract
    // @param {String} model
    // @param {Object} column_property
    // @promise
    // @see Connection::applySchemas
    addColumn(model, column_property) {
      return Promise.resolve();
    }

    //# Creates an index.
    // @abstract
    // @param {String} model
    // @param {Object} index
    // @param {Object} index.columns
    // @param {Object} index.options
    // @param {String} index.options.name
    // @param {Boolean} index.options.unique
    // @promise
    // @see Connection::applySchemas
    createIndex(model, index) {
      return Promise.resolve();
    }

    //# Creates a foreign key.
    // @abstract
    // @param {String} model
    // @param {String} column
    // @param {String} type
    // @param {Class<Model>} references
    // @promise
    // @see Connection::applySchemas
    createForeignKey(model, column, type, references) {
      return Promise.resolve();
    }

    //#
    // Drops a model from the database
    // @abstract
    // @param {String} model
    // @promise
    // @see Model.drop
    drop(model) {
      return Promise.reject('not implemented');
    }

    idToDB(value) {
      return value;
    }

    valueToDB(value, column, property) {
      if (property.type_class === types.Object || property.array) {
        return JSON.stringify(value);
      } else if (value != null) {
        return value;
      } else {
        return null;
      }
    }

    _getModelID(data) {
      return data.id;
    }

    valueToModel(value, property) {
      if (property.type_class === types.Object || property.array) {
        return JSON.parse(value);
      } else {
        return value;
      }
    }

    setValuesFromDB(instance, data, schema, selected_columns) {
      var column, i, len, parts, property, results, support_nested, value;
      if (!selected_columns) {
        selected_columns = Object.keys(schema);
      }
      support_nested = this.support_nested;
      results = [];
      for (i = 0, len = selected_columns.length; i < len; i++) {
        column = selected_columns[i];
        property = schema[column];
        parts = property._parts;
        value = support_nested ? util.getPropertyOfPath(data, parts) : data[property._dbname];
        if (value != null) {
          value = this.valueToModel(value, property);
        } else {
          value = null;
        }
        results.push(util.setPropertyOfPath(instance, parts, value));
      }
      return results;
    }

    _convertToModelInstance(model, data, options) {
      var id, instance, modelClass;
      if (options.lean) {
        model = this._connection.models[model];
        instance = {};
        this.setValuesFromDB(instance, data, model._schema, options.select);
        model._collapseNestedNulls(instance, options.select_raw, null);
        instance.id = this._getModelID(data);
        return instance;
      } else {
        id = this._getModelID(data);
        modelClass = this._connection.models[model];
        return new modelClass(data, id, options.select, options.select_raw);
      }
    }

    _convertToGroupInstance(model, data, group_by, group_fields) {
      var expr, field, i, instance, len, op, property, schema;
      instance = {};
      if (group_by) {
        schema = this._connection.models[model]._schema;
        for (i = 0, len = group_by.length; i < len; i++) {
          field = group_by[i];
          property = schema[field];
          if (property) {
            instance[field] = this.valueToModel(data[field], property);
          }
        }
      }
      for (field in group_fields) {
        expr = group_fields[field];
        op = Object.keys(expr)[0];
        if (op === '$sum' || op === '$max' || op === '$min') {
          instance[field] = Number(data[field]);
        }
      }
      return instance;
    }

    //#
    // Creates a record
    // @abstract
    // @param {String} model
    // @param {Object} data
    // @return {RecordID}
    // @promise
    create(model, data) {
      return Promise.reject(new Error('not implemented'));
    }

    //#
    // Creates records
    // @abstract
    // @param {String} model
    // @param {Array<Object>} data
    // @return {Array<RecordID>}
    // @promise
    createBulk(model, data) {
      return Promise.reject(new Error('not implemented'));
    }

    async _createBulkDefault(model, data) {
      return (await Promise.all(data.map((item) => {
        return this.create(model, item);
      })));
    }

    //#
    // Updates a record
    // @abstract
    // @param {String} model
    // @param {Object} data
    // @promise
    update(model, data) {
      return Promise.reject(new Error('not implemented'));
    }

    //#
    // Updates some fields of records that match conditions
    // @abstract
    // @param {String} model
    // @param {Object} data
    // @param {Object} conditions
    // @param {Object} options
    // @promise
    updatePartial(model, data, conditions, options) {
      return Promise.reject(new Error('not implemented'));
    }

    //#
    // Updates some fields of records that match conditions or inserts a new record
    // @abstract
    // @param {String} model
    // @param {Object} data
    // @param {Object} conditions
    // @param {Object} options
    // @promise
    upsert(model, data, conditions, options) {
      return Promise.reject(new Error('not implemented'));
    }

    //#
    // Finds a record by id
    // @abstract
    // @param {String} model
    // @param {RecordID} id
    // @param {Object} options
    // @return {Model}
    // @promise
    // @throws {Error('not found')}
    // @see Query::exec
    findById(model, id, options) {
      return Promise.reject(new Error('not implemented'));
    }

    //#
    // Finds records
    // @abstract
    // @param {String} model
    // @param {Object} conditions
    // @param {Object} options
    // @return {Array<Model>}
    // @promise
    // @see Query::exec
    find(model, conditions, options) {
      return Promise.reject(new Error('not implemented'));
    }

    //#
    // Streams matching records
    // @abstract
    // @param {String} model
    // @param {Object} conditions
    // @param {Object} options
    // @return {Readable}
    // @see Query::stream
    stream(model, conditions, options) {
      var readable;
      readable = new stream.Readable({
        objectMode: true
      });
      readable._read = function() {
        return readable.emit('error', new Error('not implemented'));
      };
      return readable;
    }

    //#
    // Counts records
    // @abstract
    // @param {String} model
    // @param {Object} conditions
    // @param {Object} options
    // @return {Number}
    // @promise
    // @see Query::count
    count(model, conditions, options) {
      return Promise.reject(new Error('not implemented'));
    }

    //#
    // Deletes records from the database
    // @abstract
    // @param {String} model
    // @param {Object} conditions
    // @return {Number}
    // @promise
    // @see Query::delete
    delete(model, conditions) {
      return Promise.reject(new Error('not implemented'));
    }

    //#
    // Closes connection
    close() {}

  };

  AdapterBase.prototype.support_fractional_seconds = true;

  AdapterBase.prototype.support_upsert = true;

  return AdapterBase;

}).call(this);

module.exports = AdapterBase;

if (process.env.NODE_ENV === 'test') {
  AdapterBase.wrapError = function(msg, cause) {
    return new Error(msg + ' caused by ' + cause.toString());
  };
}

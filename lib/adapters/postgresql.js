// Generated by CoffeeScript 2.3.1
var PostgreSQLAdapter, QueryStream, SQLAdapterBase, _, _propertyToSQL, _typeToSQL, async, e, pg, stream, types;

try {
  pg = require('pg');
} catch (error1) {
  e = error1;
  console.log('Install pg module to use this adapter');
  process.exit(1);
}

try {
  QueryStream = require('pg-query-stream');
} catch (error1) {}

SQLAdapterBase = require('./sql_base');

types = require('../types');

_ = require('lodash');

async = require('async');

stream = require('stream');

_typeToSQL = function(property) {
  if (property.array) {
    return 'JSON';
  }
  switch (property.type_class) {
    case types.String:
      return `VARCHAR(${property.type.length || 255})`;
    case types.Number:
      return 'DOUBLE PRECISION';
    case types.Boolean:
      return 'BOOLEAN';
    case types.Integer:
      return 'INT';
    case types.GeoPoint:
      return 'GEOMETRY(POINT)';
    case types.Date:
      return 'TIMESTAMP WITHOUT TIME ZONE';
    case types.Object:
      return 'JSON';
    case types.Text:
      return 'TEXT';
  }
};

_propertyToSQL = function(property) {
  var type;
  type = _typeToSQL(property);
  if (type) {
    if (property.required) {
      type += ' NOT NULL';
    } else {
      type += ' NULL';
    }
    return type;
  }
};

PostgreSQLAdapter = (function() {
  var _processSaveError;

  //#
  // Adapter for PostgreSQL
  // @namespace adapter
  class PostgreSQLAdapter extends SQLAdapterBase {
    _param_place_holder(pos) {
      return '$' + pos;
    }

    //#
    // Creates a PostgreSQL adapter
    constructor(connection) {
      super();
      this._connection = connection;
    }

    _query(sql, data, callback) {
      //console.log 'PostgreSQLAdapter:', sql
      return this._pool.query(sql, data, function(error, result) {
        return callback(error, result);
      });
    }

    _getTables(callback) {
      return this._query("SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE table_schema = 'public' AND table_type = 'BASE TABLE'", null, function(error, result) {
        var tables;
        if (error) {
          return callback(error);
        }
        tables = result.rows.map(function(table) {
          return table.table_name;
        });
        return callback(null, tables);
      });
    }

    _getSchema(table, callback) {
      return this._query("SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE table_name=$1", [table], (error, result) => {
        var column, i, len, ref, schema, type;
        if (error) {
          return callback(error);
        }
        schema = {};
        ref = result.rows;
        for (i = 0, len = ref.length; i < len; i++) {
          column = ref[i];
          type = column.data_type === 'character varying' ? new types.String(column.character_maximum_length) : column.data_type === 'double precision' ? new types.Number() : column.data_type === 'boolean' ? new types.Boolean() : column.data_type === 'integer' ? new types.Integer() : column.data_type === 'USER-DEFINED' && column.udt_schema === 'public' && column.udt_name === 'geometry' ? new types.GeoPoint() : column.data_type === 'timestamp without time zone' ? new types.Date() : column.data_type === 'json' ? new types.Object() : column.data_type === 'text' ? new types.Text() : void 0;
          schema[column.column_name] = {
            type: type,
            required: column.is_nullable === 'NO'
          };
        }
        return callback(null, schema);
      });
    }

    _getIndexes(callback) {
      // see http://stackoverflow.com/a/2213199/3239514
      return this._query("SELECT t.relname AS table_name, i.relname AS index_name, a.attname AS column_name FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND a.attnum = ANY(ix.indkey)", null, function(error, result) {
        var i, indexes, indexes_of_table, len, name, name1, ref, row;
        if (error) {
          return callback(error);
        }
        indexes = {};
        ref = result.rows;
        for (i = 0, len = ref.length; i < len; i++) {
          row = ref[i];
          indexes_of_table = indexes[name = row.table_name] || (indexes[name] = {});
          (indexes_of_table[name1 = row.index_name] || (indexes_of_table[name1] = {}))[row.column_name] = 1;
        }
        return callback(null, indexes);
      });
    }

    _getForeignKeys(callback) {
      // see http://stackoverflow.com/a/1152321/3239514
      return this._query("SELECT tc.table_name AS table_name, kcu.column_name AS column_name, ccu.table_name AS referenced_table_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY'", null, function(error, result) {
        var foreign_keys, foreign_keys_of_table, i, len, name, ref, row;
        if (error) {
          return callback(error);
        }
        foreign_keys = {};
        ref = result.rows;
        for (i = 0, len = ref.length; i < len; i++) {
          row = ref[i];
          foreign_keys_of_table = foreign_keys[name = row.table_name] || (foreign_keys[name] = {});
          foreign_keys_of_table[row.column_name] = row.referenced_table_name;
        }
        return callback(null, foreign_keys);
      });
    }

    //# @override AdapterBase::getSchemas
    getSchemas() {
      return new Promise((resolve, reject) => {
        return async.auto({
          get_tables: (callback) => {
            return this._getTables(callback);
          },
          get_table_schemas: [
            'get_tables',
            (results,
            callback) => {
              var table_schemas;
              table_schemas = {};
              return async.each(results.get_tables,
            (table,
            callback) => {
                return this._getSchema(table,
            function(error,
            schema) {
                  if (error) {
                    return callback(error);
                  }
                  table_schemas[table] = schema;
                  return callback(null);
                });
              },
            function(error) {
                if (error) {
                  return callback(error);
                }
                return callback(null,
            table_schemas);
              });
            }
          ],
          get_indexes: (callback) => {
            return this._getIndexes(callback);
          },
          get_foreign_keys: (callback) => {
            return this._getForeignKeys(callback);
          }
        }, function(error, results) {
          if (error) {
            return reject(error);
          } else {
            return resolve({
              tables: results.get_table_schemas,
              indexes: results.get_indexes,
              foreign_keys: results.get_foreign_keys
            });
          }
        });
      });
    }

    //# @override AdapterBase::createTable
    createTable(model, callback) {
      return new Promise((resolve, reject) => {
        var column, column_sql, model_class, property, ref, sql, tableName;
        model_class = this._connection.models[model];
        tableName = model_class.tableName;
        sql = [];
        sql.push('id SERIAL PRIMARY KEY');
        ref = model_class._schema;
        for (column in ref) {
          property = ref[column];
          column_sql = _propertyToSQL(property);
          if (column_sql) {
            sql.push(`"${property._dbname}" ${column_sql}`);
          }
        }
        sql = `CREATE TABLE "${tableName}" ( ${sql.join(',')} )`;
        return this._query(sql, null, (error) => {
          if (error) {
            return reject(PostgreSQLAdapter.wrapError('unknown error', error));
          } else {
            return resolve();
          }
        });
      });
    }

    //# @override AdapterBase::addColumn
    addColumn(model, column_property) {
      return new Promise((resolve, reject) => {
        var model_class, sql, tableName;
        model_class = this._connection.models[model];
        tableName = model_class.tableName;
        sql = `ALTER TABLE "${tableName}" ADD COLUMN "${column_property._dbname}" ${_propertyToSQL(column_property)}`;
        return this._query(sql, null, function(error) {
          if (error) {
            return reject(PostgreSQLAdapter.wrapError('unknown error', error));
          } else {
            return resolve();
          }
        });
      });
    }

    //# @override AdapterBase::createIndex
    createIndex(model, index, callback) {
      return new Promise((resolve, reject) => {
        var column, columns, model_class, order, ref, sql, tableName, unique;
        model_class = this._connection.models[model];
        tableName = model_class.tableName;
        columns = [];
        ref = index.columns;
        for (column in ref) {
          order = ref[column];
          columns.push(`"${column}" ${(order === -1 ? 'DESC' : 'ASC')}`);
        }
        unique = index.options.unique ? 'UNIQUE ' : '';
        sql = `CREATE ${unique}INDEX "${index.options.name}" ON "${tableName}" (${columns.join(',')})`;
        return this._query(sql, null, (error) => {
          if (error) {
            return reject(PostgreSQLAdapter.wrapError('unknown error', error));
          } else {
            return resolve();
          }
        });
      });
    }

    //# @override AdapterBase::createForeignKey
    createForeignKey(model, column, type, references) {
      return new Promise((resolve, reject) => {
        var action, model_class, sql, tableName;
        model_class = this._connection.models[model];
        tableName = model_class.tableName;
        action = (function() {
          switch (type) {
            case 'nullify':
              return 'SET NULL';
            case 'restrict':
              return 'RESTRICT';
            case 'delete':
              return 'CASCADE';
          }
        })();
        sql = `ALTER TABLE "${tableName}" ADD FOREIGN KEY ("${column}") REFERENCES "${references.tableName}"(id) ON DELETE ${action}`;
        return this._query(sql, null, function(error) {
          if (error) {
            return reject(MySQLAdapter.wrapError('unknown error', error));
          } else {
            return resolve();
          }
        });
      });
    }

    //# @override AdapterBase::drop
    drop(model, callback) {
      return new Promise((resolve, reject) => {
        var tableName;
        tableName = this._connection.models[model].tableName;
        return this._query(`DROP TABLE IF EXISTS "${tableName}"`, null, function(error) {
          if (error) {
            return reject(PostgreSQLAdapter.wrapError('unknown error', error));
          } else {
            return resolve();
          }
        });
      });
    }

    _getModelID(data) {
      return Number(data.id);
    }

    valueToModel(value, property) {
      return value;
    }

    _buildSelect(model_class, select) {
      var escape_ch, schema;
      if (!select) {
        select = Object.keys(model_class._schema);
      }
      if (select.length > 0) {
        schema = model_class._schema;
        escape_ch = this._escape_ch;
        select = select.map(function(column) {
          var property;
          property = schema[column];
          column = escape_ch + schema[column]._dbname + escape_ch;
          if (property.type_class === types.GeoPoint) {
            return `ARRAY[ST_X(${column}), ST_Y(${column})] AS ${column}`;
          } else {
            return column;
          }
        });
        return 'id,' + select.join(',');
      } else {
        return 'id';
      }
    }

    _buildUpdateSetOfColumn(property, data, values, fields, places, insert) {
      var dbname, value;
      dbname = property._dbname;
      value = data[dbname];
      if (property.type_class === types.GeoPoint) {
        values.push(value[0]);
        values.push(value[1]);
        if (insert) {
          fields.push(`"${dbname}"`);
          return places.push(`ST_Point($${values.length - 1}, $${values.length})`);
        } else {
          return fields.push(`"${dbname}"=ST_Point($${values.length - 1}, $${values.length})`);
        }
      } else if ((value != null ? value.$inc : void 0) != null) {
        values.push(value.$inc);
        return fields.push(`"${dbname}"="${dbname}"+$${values.length}`);
      } else {
        values.push(value);
        if (insert) {
          fields.push(`"${dbname}"`);
          return places.push('$' + values.length);
        } else {
          return fields.push(`"${dbname}"=$${values.length}`);
        }
      }
    }

    _buildUpdateSet(model, data, values, insert) {
      var column, fields, places, property, schema;
      schema = this._connection.models[model]._schema;
      fields = [];
      places = [];
      for (column in schema) {
        property = schema[column];
        this._buildUpdateSetOfColumn(property, data, values, fields, places, insert);
      }
      return [fields.join(','), places.join(',')];
    }

    _buildPartialUpdateSet(model, data, values) {
      var column, fields, places, property, schema, value;
      schema = this._connection.models[model]._schema;
      fields = [];
      places = [];
      for (column in data) {
        value = data[column];
        property = _.find(schema, function(item) {
          return item._dbname === column;
        });
        this._buildUpdateSetOfColumn(property, data, values, fields, places);
      }
      return [fields.join(','), places.join(',')];
    }

    //# @override AdapterBase::create
    create(model, data, callback) {
      var fields, places, sql, tableName, values;
      tableName = this._connection.models[model].tableName;
      values = [];
      [fields, places] = this._buildUpdateSet(model, data, values, true);
      sql = `INSERT INTO "${tableName}" (${fields}) VALUES (${places}) RETURNING id`;
      return this._query(sql, values, function(error, result) {
        var rows;
        rows = result != null ? result.rows : void 0;
        if (error) {
          return _processSaveError(tableName, error, callback);
        }
        if ((rows != null ? rows.length : void 0) === 1 && (rows[0].id != null)) {
          return callback(null, rows[0].id);
        } else {
          return callback(new Error('unexpected rows'));
        }
      });
    }

    //# @override AdapterBase::createBulk
    createBulk(model, data, callback) {
      var fields, places, sql, tableName, values;
      tableName = this._connection.models[model].tableName;
      values = [];
      fields = void 0;
      places = [];
      data.forEach((item) => {
        var places_sub;
        [fields, places_sub] = this._buildUpdateSet(model, item, values, true);
        return places.push('(' + places_sub + ')');
      });
      sql = `INSERT INTO "${tableName}" (${fields}) VALUES ${places.join(',')} RETURNING id`;
      return this._query(sql, values, function(error, result) {
        var ids;
        if (error) {
          return _processSaveError(tableName, error, callback);
        }
        ids = result != null ? result.rows.map(function(row) {
          return row.id;
        }) : void 0;
        if (ids.length === data.length) {
          return callback(null, ids);
        } else {
          return callback(new Error('unexpected rows'));
        }
      });
    }

    //# @override AdapterBase::update
    update(model, data, callback) {
      var fields, sql, tableName, values;
      tableName = this._connection.models[model].tableName;
      values = [];
      [fields] = this._buildUpdateSet(model, data, values);
      values.push(data.id);
      sql = `UPDATE "${tableName}" SET ${fields} WHERE id=$${values.length}`;
      return this._query(sql, values, function(error) {
        if (error) {
          return _processSaveError(tableName, error, callback);
        }
        return callback(null);
      });
    }

    //# @override AdapterBase::updatePartial
    updatePartial(model, data, conditions, options, callback) {
      var fields, sql, tableName, values;
      tableName = this._connection.models[model].tableName;
      values = [];
      [fields] = this._buildPartialUpdateSet(model, data, values);
      sql = `UPDATE "${tableName}" SET ${fields}`;
      if (conditions.length > 0) {
        try {
          sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, values);
        } catch (error1) {
          e = error1;
          return callback(e);
        }
      }
      return this._query(sql, values, function(error, result) {
        if (error) {
          return _processSaveError(tableName, error, callback);
        }
        return callback(null, result.rowCount);
      });
    }

    //# @override AdapterBase::findById
    findById(model, id, options, callback) {
      var select, sql, tableName;
      select = this._buildSelect(this._connection.models[model], options.select);
      tableName = this._connection.models[model].tableName;
      sql = `SELECT ${select} FROM "${tableName}" WHERE id=$1 LIMIT 1`;
      if (options.explain) {
        return this._query(`EXPLAIN ${sql}`, [id], function(error, result) {
          if (error) {
            return callback(error);
          }
          return callback(null, result);
        });
      }
      return this._query(sql, [id], (error, result) => {
        var rows;
        rows = result != null ? result.rows : void 0;
        if (error) {
          return callback(PostgreSQLAdapter.wrapError('unknown error', error));
        }
        if ((rows != null ? rows.length : void 0) === 1) {
          return callback(null, this._convertToModelInstance(model, rows[0], options));
        } else if ((rows != null ? rows.length : void 0) > 1) {
          return callback(new Error('unknown error'));
        } else {
          return callback(new Error('not found'));
        }
      });
    }

    _buildSqlForFind(model, conditions, options) {
      var field, location, model_class, order_by, orders, params, schema, select, sql, tableName;
      if (options.group_by || options.group_fields) {
        select = this._buildGroupFields(options.group_by, options.group_fields);
      } else {
        select = this._buildSelect(this._connection.models[model], options.select);
      }
      if ((options.near != null) && (field = Object.keys(options.near)[0])) {
        order_by = `"${field}_distance"`;
        location = options.near[field];
        select += `,ST_Distance("${field}",ST_Point(${location[0]},${location[1]})) AS "${field}_distance"`;
      }
      params = [];
      tableName = this._connection.models[model].tableName;
      sql = `SELECT ${select} FROM "${tableName}"`;
      if (conditions.length > 0) {
        sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, params);
      }
      if (options.group_by) {
        sql += ' GROUP BY ' + options.group_by.join(',');
      }
      if (options.conditions_of_group.length > 0) {
        sql += ' HAVING ' + this._buildWhere(options.group_fields, options.conditions_of_group, params);
      }
      if ((options != null ? options.orders.length : void 0) > 0 || order_by) {
        model_class = this._connection.models[model];
        schema = model_class._schema;
        orders = options.orders.map(function(order) {
          var column, ref;
          if (order[0] === '-') {
            column = order.slice(1);
            order = 'DESC';
          } else {
            column = order;
            order = 'ASC';
          }
          column = ((ref = schema[column]) != null ? ref._dbname : void 0) || column;
          return `"${column}" ${order}`;
        });
        if (order_by) {
          orders.push(order_by);
        }
        sql += ' ORDER BY ' + orders.join(',');
      }
      if ((options != null ? options.limit : void 0) != null) {
        sql += ' LIMIT ' + options.limit;
        if ((options != null ? options.skip : void 0) != null) {
          sql += ' OFFSET ' + options.skip;
        }
      } else if ((options != null ? options.skip : void 0) != null) {
        sql += ' LIMIT ALL OFFSET ' + options.skip;
      }
      //console.log sql, params
      return [sql, params];
    }

    //# @override AdapterBase::find
    find(model, conditions, options, callback) {
      var params, sql;
      try {
        [sql, params] = this._buildSqlForFind(model, conditions, options);
      } catch (error1) {
        e = error1;
        return callback(e);
      }
      if (options.explain) {
        return this._query(`EXPLAIN ${sql}`, params, function(error, result) {
          if (error) {
            return callback(error);
          }
          return callback(null, result);
        });
      }
      return this._query(sql, params, (error, result) => {
        var rows;
        rows = result != null ? result.rows : void 0;
        if (error) {
          return callback(PostgreSQLAdapter.wrapError('unknown error', error));
        }
        if (options.group_fields) {
          return callback(null, rows.map((record) => {
            return this._convertToGroupInstance(model, record, options.group_by, options.group_fields);
          }));
        } else {
          return callback(null, rows.map((record) => {
            return this._convertToModelInstance(model, record, options);
          }));
        }
      });
    }

    //# @override AdapterBase::stream
    stream(model, conditions, options, callback) {
      var params, readable, sql, transformer;
      if (!QueryStream) {
        console.log('Install pg-query-stream module to use stream');
        process.exit(1);
      }
      try {
        [sql, params] = this._buildSqlForFind(model, conditions, options);
      } catch (error1) {
        e = error1;
        readable = new stream.Readable({
          objectMode: true
        });
        readable._read = function() {
          return readable.emit('error', e);
        };
        return readable;
      }
      transformer = new stream.Transform({
        objectMode: true
      });
      transformer._transform = (record, encoding, callback) => {
        transformer.push(this._convertToModelInstance(model, record, options));
        return callback();
      };
      this._pool.connect().then(function(client) {
        return client.query(new QueryStream(sql, params)).on('end', function() {
          return client.release();
        }).on('error', function(error) {
          return transformer.emit('error', error);
        }).pipe(transformer);
      });
      return transformer;
    }

    //# @override AdapterBase::count
    count(model, conditions, options, callback) {
      var params, sql, tableName;
      params = [];
      tableName = this._connection.models[model].tableName;
      sql = `SELECT COUNT(*) AS count FROM "${tableName}"`;
      if (conditions.length > 0) {
        try {
          sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, params);
        } catch (error1) {
          e = error1;
          return callback(e);
        }
      }
      if (options.group_by) {
        sql += ' GROUP BY ' + options.group_by.join(',');
        if (options.conditions_of_group.length > 0) {
          try {
            sql += ' HAVING ' + this._buildWhere(options.group_fields, options.conditions_of_group, params);
          } catch (error1) {
            e = error1;
            return callback(e);
          }
        }
        sql = `SELECT COUNT(*) AS count FROM (${sql}) _sub`;
      }
      //console.log sql, params
      return this._query(sql, params, (error, result) => {
        var rows;
        rows = result != null ? result.rows : void 0;
        if (error) {
          return callback(PostgreSQLAdapter.wrapError('unknown error', error));
        }
        if ((rows != null ? rows.length : void 0) !== 1) {
          return callback(new Error('unknown error'));
        }
        return callback(null, Number(rows[0].count));
      });
    }

    //# @override AdapterBase::delete
    delete(model, conditions, callback) {
      var params, sql, tableName;
      params = [];
      tableName = this._connection.models[model].tableName;
      sql = `DELETE FROM "${tableName}"`;
      if (conditions.length > 0) {
        try {
          sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, params);
        } catch (error1) {
          e = error1;
          return callback(e);
        }
      }
      //console.log sql, params
      return this._query(sql, params, function(error, result) {
        if (error && error.code === '23503') {
          return callback(new Error('rejected'));
        }
        if (error || (result == null)) {
          return callback(PostgreSQLAdapter.wrapError('unknown error', error));
        }
        return callback(null, result.rowCount);
      });
    }

    //#
    // Connects to the database
    // @param {Object} settings
    // @param {String} [settings.host]
    // @param {Number} [settings.port]
    // @param {String} [settings.user]
    // @param {String} [settings.password]
    // @param {String} settings.database
    // @nodejscallback
    connect(settings, callback) {
      var pool;
      // connect
      pool = new pg.Pool({
        host: settings.host,
        port: settings.port,
        user: settings.user,
        password: settings.password,
        database: settings.database
      });
      return pool.connect().then((client) => {
        client.release();
        this._pool = pool;
        return callback(null);
      }).catch(function(error) {
        if (error.code === '3D000') {
          return callback(new Error('database does not exist'));
        }
        return callback(PostgreSQLAdapter.wrapError('failed to connect', error));
      });
    }

    //# @override AdapterBase::close
    close() {
      this._pool.end();
      return this._pool = null;
    }

    //#
    // Exposes pg module's query method
    query() {
      return this._pool.query.apply(this._pool, arguments);
    }

  };

  PostgreSQLAdapter.prototype.key_type = types.Integer;

  PostgreSQLAdapter.prototype.support_geopoint = true;

  PostgreSQLAdapter.prototype.support_string_type_with_length = true;

  PostgreSQLAdapter.prototype.native_integrity = true;

  PostgreSQLAdapter.prototype._contains_op = 'ILIKE';

  PostgreSQLAdapter.prototype._regexp_op = '~*';

  _processSaveError = function(tableName, error, callback) {
    var column, key;
    if (error.code === '42P01') {
      error = new Error('table does not exist');
    } else if (error.code === '23505') {
      column = '';
      key = error.message.match(/unique constraint \"(.*)\"/);
      if (key != null) {
        column = key[1];
        key = column.match(new RegExp(`${tableName}_([^']*)_key`));
        if (key != null) {
          column = key[1];
        }
        column = ' ' + column;
      }
      error = new Error('duplicated' + column);
    } else {
      error = PostgreSQLAdapter.wrapError('unknown error', error);
    }
    return callback(error);
  };

  return PostgreSQLAdapter;

}).call(this);

module.exports = function(connection) {
  return new PostgreSQLAdapter(connection);
};

// Generated by CoffeeScript 1.12.5
(function() {
  var MySQLAdapter, SQLAdapterBase, _, _propertyToSQL, _typeToSQL, async, e, mysql, stream, types,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  try {
    mysql = require('mysql');
  } catch (error1) {
    e = error1;
    console.log('Install mysql module to use this adapter');
    process.exit(1);
  }

  SQLAdapterBase = require('./sql_base');

  types = require('../types');

  _ = require('lodash');

  async = require('async');

  stream = require('stream');

  _typeToSQL = function(property, support_fractional_seconds) {
    if (property.array) {
      return 'TEXT';
    }
    switch (property.type_class) {
      case types.String:
        return "VARCHAR(" + (property.type.length || 255) + ")";
      case types.Number:
        return 'DOUBLE';
      case types.Boolean:
        return 'BOOLEAN';
      case types.Integer:
        return 'INT';
      case types.GeoPoint:
        return 'POINT';
      case types.Date:
        if (support_fractional_seconds) {
          return 'DATETIME(3)';
        } else {
          return 'DATETIME';
        }
        break;
      case types.Object:
        return 'TEXT';
      case types.Text:
        return 'TEXT';
    }
  };

  _propertyToSQL = function(property, support_fractional_seconds) {
    var type;
    type = _typeToSQL(property, support_fractional_seconds);
    if (type) {
      if (property.required) {
        type += ' NOT NULL';
      } else {
        type += ' NULL';
      }
      return type;
    }
  };

  MySQLAdapter = (function(superClass) {
    var _processSaveError;

    extend(MySQLAdapter, superClass);

    MySQLAdapter.prototype.key_type = types.Integer;

    MySQLAdapter.prototype.support_geopoint = true;

    MySQLAdapter.prototype.support_string_type_with_length = true;

    MySQLAdapter.prototype.native_integrity = true;

    MySQLAdapter.prototype._escape_ch = '`';

    function MySQLAdapter(connection) {
      this._connection = connection;
    }

    MySQLAdapter.prototype._query = function(sql, data, callback) {
      return this._client.query(sql, data, callback);
    };

    MySQLAdapter.prototype._getTables = function(callback) {
      return this._query("SHOW TABLES", function(error, tables) {
        if (error) {
          return callback(error);
        }
        tables = tables.map(function(table) {
          var key;
          key = Object.keys(table)[0];
          return table[key];
        });
        return callback(null, tables);
      });
    };

    MySQLAdapter.prototype._getSchema = function(table, callback) {
      return this._query("SHOW COLUMNS FROM `" + table + "`", function(error, columns) {
        var column, j, len, schema, type;
        if (error) {
          return callback(error);
        }
        schema = {};
        for (j = 0, len = columns.length; j < len; j++) {
          column = columns[j];
          type = /^varchar\((\d*)\)/i.test(column.Type) ? new types.String(RegExp.$1) : /^double/i.test(column.Type) ? new types.Number() : /^tinyint\(1\)/i.test(column.Type) ? new types.Boolean() : /^int/i.test(column.Type) ? new types.Integer() : /^point/i.test(column.Type) ? new types.GeoPoint() : /^datetime/i.test(column.Type) ? new types.Date() : /^text/i.test(column.Type) ? new types.Object() : void 0;
          schema[column.Field] = {
            type: type,
            required: column.Null === 'NO'
          };
        }
        return callback(null, schema);
      });
    };

    MySQLAdapter.prototype._getIndexes = function(callback) {
      return this._query("SELECT * FROM INFORMATION_SCHEMA.STATISTICS WHERE TABLE_SCHEMA = ? ORDER BY SEQ_IN_INDEX", [this._database], function(error, rows) {
        var indexes, indexes_of_table, j, len, name, name1, row;
        if (error) {
          return callback(error);
        }
        indexes = {};
        for (j = 0, len = rows.length; j < len; j++) {
          row = rows[j];
          indexes_of_table = indexes[name = row.TABLE_NAME] || (indexes[name] = {});
          (indexes_of_table[name1 = row.INDEX_NAME] || (indexes_of_table[name1] = {}))[row.COLUMN_NAME] = 1;
        }
        return callback(null, indexes);
      });
    };

    MySQLAdapter.prototype._getForeignKeys = function(callback) {
      return this._query("SELECT * FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE REFERENCED_TABLE_NAME IS NOT NULL AND CONSTRAINT_SCHEMA = ?", [this._database], function(error, rows) {
        var foreign_keys, foreign_keys_of_table, j, len, name, row;
        if (error) {
          return callback(error);
        }
        foreign_keys = {};
        for (j = 0, len = rows.length; j < len; j++) {
          row = rows[j];
          foreign_keys_of_table = foreign_keys[name = row.TABLE_NAME] || (foreign_keys[name] = {});
          foreign_keys_of_table[row.COLUMN_NAME] = row.REFERENCED_TABLE_NAME;
        }
        return callback(null, foreign_keys);
      });
    };

    MySQLAdapter.prototype.getSchemas = function(callback) {
      return async.auto({
        get_tables: (function(_this) {
          return function(callback) {
            return _this._getTables(callback);
          };
        })(this),
        get_table_schemas: [
          'get_tables', (function(_this) {
            return function(results, callback) {
              var table_schemas;
              table_schemas = {};
              return async.each(results.get_tables, function(table, callback) {
                return _this._getSchema(table, function(error, schema) {
                  if (error) {
                    return callback(error);
                  }
                  table_schemas[table] = schema;
                  return callback(null);
                });
              }, function(error) {
                if (error) {
                  return callback(error);
                }
                return callback(null, table_schemas);
              });
            };
          })(this)
        ],
        get_indexes: (function(_this) {
          return function(callback) {
            return _this._getIndexes(callback);
          };
        })(this),
        get_foreign_keys: (function(_this) {
          return function(callback) {
            return _this._getForeignKeys(callback);
          };
        })(this)
      }, function(error, results) {
        return callback(error, {
          tables: results.get_table_schemas,
          indexes: results.get_indexes,
          foreign_keys: results.get_foreign_keys
        });
      });
    };

    MySQLAdapter.prototype.createTable = function(model, callback) {
      var column, column_sql, model_class, property, ref, sql, tableName;
      model_class = this._connection.models[model];
      tableName = model_class.tableName;
      sql = [];
      sql.push('id INT NOT NULL AUTO_INCREMENT UNIQUE PRIMARY KEY');
      ref = model_class._schema;
      for (column in ref) {
        property = ref[column];
        column_sql = _propertyToSQL(property, this.support_fractional_seconds);
        if (column_sql) {
          sql.push("`" + property._dbname + "` " + column_sql);
        }
      }
      sql = "CREATE TABLE `" + tableName + "` ( " + (sql.join(',')) + " )";
      sql += " DEFAULT CHARSET=" + (this._settings.charset || 'utf8');
      sql += " COLLATE=" + (this._settings.collation || 'utf8_unicode_ci');
      return this._query(sql, function(error) {
        if (error) {
          return callback(MySQLAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    MySQLAdapter.prototype.addColumn = function(model, column_property, callback) {
      var model_class, sql, tableName;
      model_class = this._connection.models[model];
      tableName = model_class.tableName;
      sql = "ALTER TABLE `" + tableName + "` ADD COLUMN `" + column_property._dbname + "` " + (_propertyToSQL(column_property, this.support_fractional_seconds));
      return this._query(sql, function(error) {
        if (error) {
          return callback(MySQLAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    MySQLAdapter.prototype.createIndex = function(model, index, callback) {
      var column, columns, model_class, order, ref, sql, tableName, unique;
      model_class = this._connection.models[model];
      tableName = model_class.tableName;
      columns = [];
      ref = index.columns;
      for (column in ref) {
        order = ref[column];
        columns.push("`" + column + "` " + (order === -1 ? 'DESC' : 'ASC'));
      }
      unique = index.options.unique ? 'UNIQUE ' : '';
      sql = "CREATE " + unique + "INDEX `" + index.options.name + "` ON `" + tableName + "` (" + (columns.join(',')) + ")";
      return this._query(sql, function(error) {
        if (error) {
          return callback(MySQLAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    MySQLAdapter.prototype.createForeignKey = function(model, column, type, references, callback) {
      var action, model_class, sql, tableName;
      model_class = this._connection.models[model];
      tableName = model_class.tableName;
      action = (function() {
        switch (type) {
          case 'nullify':
            return 'SET NULL';
          case 'restrict':
            return 'RESTRICT';
          case 'delete':
            return 'CASCADE';
        }
      })();
      sql = "ALTER TABLE `" + tableName + "` ADD FOREIGN KEY (`" + column + "`) REFERENCES `" + references.tableName + "`(id) ON DELETE " + action;
      return this._query(sql, function(error) {
        if (error) {
          return callback(MySQLAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    MySQLAdapter.prototype.drop = function(model, callback) {
      var tableName;
      tableName = this._connection.models[model].tableName;
      return this._query("DROP TABLE IF EXISTS `" + tableName + "`", function(error) {
        if (error) {
          return callback(MySQLAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    MySQLAdapter.prototype._getModelID = function(data) {
      return Number(data.id);
    };

    MySQLAdapter.prototype.valueToModel = function(value, property) {
      if (property.type_class === types.Object || property.array) {
        try {
          return JSON.parse(value);
        } catch (error1) {
          return null;
        }
      } else if (property.type_class === types.GeoPoint) {
        return [value.x, value.y];
      } else if (property.type_class === types.Boolean) {
        return value !== 0;
      } else {
        return value;
      }
    };

    _processSaveError = function(error, callback) {
      var key;
      if (error.code === 'ER_NO_SUCH_TABLE') {
        error = new Error('table does not exist');
      } else if (error.code === 'ER_DUP_ENTRY') {
        key = error.message.match(/for key '([^']*)'/);
        error = new Error('duplicated ' + (key != null ? key[1] : void 0));
      } else if (error.code === 'ER_BAD_NULL_ERROR') {
        key = error.message.match(/Column '([^']*)'/);
        error = new Error("'" + (key != null ? key[1] : void 0) + "' is required");
      } else {
        error = MySQLAdapter.wrapError('unknown error', error);
      }
      return callback(error);
    };

    MySQLAdapter.prototype._buildUpdateSetOfColumn = function(property, data, values, fields, places, insert) {
      var dbname, value;
      dbname = property._dbname;
      value = data[dbname];
      if (property.type_class === types.GeoPoint) {
        values.push(value[0]);
        values.push(value[1]);
        if (insert) {
          fields.push("`" + dbname + "`");
          return places.push('POINT(?,?)');
        } else {
          return fields.push("`" + dbname + "`=POINT(?,?)");
        }
      } else if ((value != null ? value.$inc : void 0) != null) {
        values.push(value.$inc);
        return fields.push("`" + dbname + "`=`" + dbname + "`+?");
      } else {
        values.push(value);
        if (insert) {
          fields.push("`" + dbname + "`");
          return places.push('?');
        } else {
          return fields.push("`" + dbname + "`=?");
        }
      }
    };

    MySQLAdapter.prototype._buildUpdateSet = function(model, data, values, insert) {
      var column, fields, places, property, schema;
      schema = this._connection.models[model]._schema;
      fields = [];
      places = [];
      for (column in schema) {
        property = schema[column];
        this._buildUpdateSetOfColumn(property, data, values, fields, places, insert);
      }
      return [fields.join(','), places.join(',')];
    };

    MySQLAdapter.prototype._buildPartialUpdateSet = function(model, data, values) {
      var column, fields, places, property, schema, value;
      schema = this._connection.models[model]._schema;
      fields = [];
      places = [];
      for (column in data) {
        value = data[column];
        property = _.find(schema, function(item) {
          return item._dbname === column;
        });
        this._buildUpdateSetOfColumn(property, data, values, fields, places);
      }
      return [fields.join(','), places.join(',')];
    };

    MySQLAdapter.prototype.create = function(model, data, callback) {
      var fields, places, ref, sql, tableName, values;
      tableName = this._connection.models[model].tableName;
      values = [];
      ref = this._buildUpdateSet(model, data, values, true), fields = ref[0], places = ref[1];
      sql = "INSERT INTO `" + tableName + "` (" + fields + ") VALUES (" + places + ")";
      return this._query(sql, values, function(error, result) {
        var id;
        if (error) {
          return _processSaveError(error, callback);
        }
        if (id = result != null ? result.insertId : void 0) {
          return callback(null, id);
        } else {
          return callback(new Error('unexpected result'));
        }
      });
    };

    MySQLAdapter.prototype.createBulk = function(model, data, callback) {
      var fields, places, sql, tableName, values;
      tableName = this._connection.models[model].tableName;
      values = [];
      fields = void 0;
      places = [];
      data.forEach((function(_this) {
        return function(item) {
          var places_sub, ref;
          ref = _this._buildUpdateSet(model, item, values, true), fields = ref[0], places_sub = ref[1];
          return places.push('(' + places_sub + ')');
        };
      })(this));
      sql = "INSERT INTO `" + tableName + "` (" + fields + ") VALUES " + (places.join(','));
      return this._query(sql, values, function(error, result) {
        var id;
        if (error) {
          return _processSaveError(error, callback);
        }
        if (id = result != null ? result.insertId : void 0) {
          return callback(null, data.map(function(item, i) {
            return id + i;
          }));
        } else {
          return callback(new Error('unexpected result'));
        }
      });
    };

    MySQLAdapter.prototype.update = function(model, data, callback) {
      var fields, sql, tableName, values;
      tableName = this._connection.models[model].tableName;
      values = [];
      fields = this._buildUpdateSet(model, data, values)[0];
      values.push(data.id);
      sql = "UPDATE `" + tableName + "` SET " + fields + " WHERE id=?";
      return this._query(sql, values, function(error) {
        if (error) {
          return _processSaveError(error, callback);
        }
        return callback(null);
      });
    };

    MySQLAdapter.prototype.updatePartial = function(model, data, conditions, options, callback) {
      var fields, sql, tableName, values;
      tableName = this._connection.models[model].tableName;
      values = [];
      fields = this._buildPartialUpdateSet(model, data, values)[0];
      sql = "UPDATE `" + tableName + "` SET " + fields;
      if (conditions.length > 0) {
        try {
          sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, values);
        } catch (error1) {
          e = error1;
          return callback(e);
        }
      }
      return this._query(sql, values, function(error, result) {
        if (error) {
          return _processSaveError(error, callback);
        }
        if (result == null) {
          return callback(MySQLAdapter.wrapError('unknown error'));
        }
        return callback(null, result.affectedRows);
      });
    };

    MySQLAdapter.prototype.upsert = function(model, data, conditions, options, callback) {
      var condition, fields, insert_data, j, key, len, places, ref, sql, tableName, value, values;
      tableName = this._connection.models[model].tableName;
      insert_data = {};
      for (key in data) {
        value = data[key];
        if ((value != null ? value.$inc : void 0) != null) {
          insert_data[key] = value.$inc;
        } else {
          insert_data[key] = value;
        }
      }
      for (j = 0, len = conditions.length; j < len; j++) {
        condition = conditions[j];
        for (key in condition) {
          value = condition[key];
          insert_data[key] = value;
        }
      }
      values = [];
      ref = this._buildUpdateSet(model, insert_data, values, true), fields = ref[0], places = ref[1];
      sql = "INSERT INTO `" + tableName + "` (" + fields + ") VALUES (" + places + ")";
      fields = this._buildPartialUpdateSet(model, data, values)[0];
      sql += " ON DUPLICATE KEY UPDATE " + fields;
      return this._query(sql, values, function(error, result) {
        if (error) {
          return _processSaveError(error, callback);
        }
        return callback(null);
      });
    };

    MySQLAdapter.prototype.findById = function(model, id, options, callback) {
      var select, sql, tableName;
      id = this._convertValueType(id, this.key_type);
      select = this._buildSelect(this._connection.models[model], options.select);
      tableName = this._connection.models[model].tableName;
      sql = "SELECT " + select + " FROM `" + tableName + "` WHERE id=? LIMIT 1";
      if (options.explain) {
        return this._query("EXPLAIN " + sql, id, function(error, result) {
          if (error) {
            return callback(error);
          }
          return callback(null, result);
        });
      }
      return this._query(sql, id, (function(_this) {
        return function(error, result) {
          if (error) {
            return callback(MySQLAdapter.wrapError('unknown error', error));
          }
          if ((result != null ? result.length : void 0) === 1) {
            return callback(null, _this._convertToModelInstance(model, result[0], options));
          } else if ((result != null ? result.length : void 0) > 1) {
            return callback(new Error('unknown error'));
          } else {
            return callback(new Error('not found'));
          }
        };
      })(this));
    };

    MySQLAdapter.prototype._buildSqlForFind = function(model, conditions, options) {
      var field, location, model_class, order_by, orders, params, schema, select, sql, tableName;
      if (options.group_by || options.group_fields) {
        select = this._buildGroupFields(options.group_by, options.group_fields);
      } else {
        select = this._buildSelect(this._connection.models[model], options.select);
      }
      if ((options.near != null) && (field = Object.keys(options.near)[0])) {
        order_by = "`" + field + "_distance`";
        location = options.near[field];
        select += ",GLENGTH(LINESTRING(`" + field + "`,POINT(" + location[0] + "," + location[1] + "))) AS `" + field + "_distance`";
      }
      params = [];
      tableName = this._connection.models[model].tableName;
      sql = "SELECT " + select + " FROM `" + tableName + "`";
      if (conditions.length > 0) {
        sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, params);
      }
      if (options.group_by) {
        sql += ' GROUP BY ' + options.group_by.join(',');
      }
      if (options.conditions_of_group.length > 0) {
        sql += ' HAVING ' + this._buildWhere(options.group_fields, options.conditions_of_group, params);
      }
      if ((options != null ? options.orders.length : void 0) > 0 || order_by) {
        model_class = this._connection.models[model];
        schema = model_class._schema;
        orders = options.orders.map(function(order) {
          var column, ref;
          if (order[0] === '-') {
            column = order.slice(1);
            order = 'DESC';
          } else {
            column = order;
            order = 'ASC';
          }
          column = ((ref = schema[column]) != null ? ref._dbname : void 0) || column;
          return "`" + column + "` " + order;
        });
        if (order_by) {
          orders.push(order_by);
        }
        sql += ' ORDER BY ' + orders.join(',');
      }
      if ((options != null ? options.limit : void 0) != null) {
        sql += ' LIMIT ' + options.limit;
        if ((options != null ? options.skip : void 0) != null) {
          sql += ' OFFSET ' + options.skip;
        }
      } else if ((options != null ? options.skip : void 0) != null) {
        sql += ' LIMIT 2147483647 OFFSET ' + options.skip;
      }
      return [sql, params];
    };

    MySQLAdapter.prototype.find = function(model, conditions, options, callback) {
      var params, ref, sql;
      try {
        ref = this._buildSqlForFind(model, conditions, options), sql = ref[0], params = ref[1];
      } catch (error1) {
        e = error1;
        return callback(e);
      }
      if (options.explain) {
        return this._query("EXPLAIN " + sql, params, function(error, result) {
          if (error) {
            return callback(error);
          }
          return callback(null, result);
        });
      }
      return this._query(sql, params, (function(_this) {
        return function(error, result) {
          if (error) {
            return callback(MySQLAdapter.wrapError('unknown error', error));
          }
          if (options.group_fields) {
            return callback(null, result.map(function(record) {
              return _this._convertToGroupInstance(model, record, options.group_by, options.group_fields);
            }));
          } else {
            return callback(null, result.map(function(record) {
              return _this._convertToModelInstance(model, record, options);
            }));
          }
        };
      })(this));
    };

    MySQLAdapter.prototype.stream = function(model, conditions, options) {
      var params, readable, ref, sql, transformer;
      try {
        ref = this._buildSqlForFind(model, conditions, options), sql = ref[0], params = ref[1];
      } catch (error1) {
        e = error1;
        readable = new stream.Readable({
          objectMode: true
        });
        readable._read = function() {
          return readable.emit('error', e);
        };
        return readable;
      }
      transformer = new stream.Transform({
        objectMode: true
      });
      transformer._transform = (function(_this) {
        return function(record, encoding, callback) {
          transformer.push(_this._convertToModelInstance(model, record, options));
          return callback();
        };
      })(this);
      this._query(sql, params).stream().on('error', function(error) {
        return transformer.emit('error', error);
      }).pipe(transformer);
      return transformer;
    };

    MySQLAdapter.prototype.count = function(model, conditions, options, callback) {
      var params, sql, tableName;
      params = [];
      tableName = this._connection.models[model].tableName;
      sql = "SELECT COUNT(*) AS count FROM `" + tableName + "`";
      if (conditions.length > 0) {
        try {
          sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, params);
        } catch (error1) {
          e = error1;
          return callback(e);
        }
      }
      if (options.group_by) {
        sql += ' GROUP BY ' + options.group_by.join(',');
        if (options.conditions_of_group.length > 0) {
          try {
            sql += ' HAVING ' + this._buildWhere(options.group_fields, options.conditions_of_group, params);
          } catch (error1) {
            e = error1;
            return callback(e);
          }
        }
        sql = "SELECT COUNT(*) AS count FROM (" + sql + ") _sub";
      }
      return this._query(sql, params, (function(_this) {
        return function(error, result) {
          if (error) {
            return callback(MySQLAdapter.wrapError('unknown error', error));
          }
          if ((result != null ? result.length : void 0) !== 1) {
            return callback(new Error('unknown error'));
          }
          return callback(null, Number(result[0].count));
        };
      })(this));
    };

    MySQLAdapter.prototype["delete"] = function(model, conditions, callback) {
      var params, sql, tableName;
      params = [];
      tableName = this._connection.models[model].tableName;
      sql = "DELETE FROM `" + tableName + "`";
      if (conditions.length > 0) {
        try {
          sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, params);
        } catch (error1) {
          e = error1;
          return callback(e);
        }
      }
      return this._query(sql, params, function(error, result) {
        var ref;
        if (error && ((ref = error.code) === 'ER_ROW_IS_REFERENCED_' || ref === 'ER_ROW_IS_REFERENCED_2')) {
          return callback(new Error('rejected'));
        }
        if (error || (result == null)) {
          return callback(MySQLAdapter.wrapError('unknown error', error));
        }
        return callback(null, result.affectedRows);
      });
    };

    MySQLAdapter.prototype.connect = function(settings, callback) {
      var client;
      client = mysql.createConnection({
        host: settings.host,
        port: settings.port,
        user: settings.user,
        password: settings.password,
        charset: settings.charset
      });
      this._database = settings.database;
      this._settings = settings;
      return client.connect((function(_this) {
        return function(error) {
          if (error) {
            client.end();
            return callback(MySQLAdapter.wrapError('failed to connect', error));
          }
          return _this._createDatabase(client, function(error) {
            if (error) {
              client.end();
              return callback(error);
            }
            return _this._checkFeatures(client, function(error) {
              client.end();
              if (error) {
                return callback(error);
              }
              _this._client = mysql.createPool({
                host: settings.host,
                port: settings.port,
                user: settings.user,
                password: settings.password,
                charset: settings.charset,
                database: settings.database,
                connectionLimit: settings.pool_size || 10
              });
              return callback(null);
            });
          });
        };
      })(this));
    };

    MySQLAdapter.prototype._createDatabase = function(client, callback) {
      return client.query("USE `" + this._database + "`", (function(_this) {
        return function(error) {
          var msg;
          if (!error) {
            return callback(null);
          }
          if (error.code === 'ER_BAD_DB_ERROR') {
            return client.query("CREATE DATABASE `" + _this._database + "`", function(error) {
              if (error) {
                return callback(MySQLAdapter.wrapError('unknown error', error));
              }
              return _this._createDatabase(client, callback);
            });
          } else {
            msg = error.code === 'ER_DBACCESS_DENIED_ERROR' ? "no access right to the database '" + _this._database + "'" : 'unknown error';
            return callback(MySQLAdapter.wrapError(msg, error));
          }
        };
      })(this));
    };

    MySQLAdapter.prototype._checkFeatures = function(client, callback) {
      return client.query("CREATE TABLE _temp (date DATETIME(10))", (function(_this) {
        return function(error) {
          if (error.code === 'ER_PARSE_ERROR') {
            _this.support_fractional_seconds = false;
          } else if (error.code === 'ER_TOO_BIG_PRECISION') {
            _this.support_fractional_seconds = true;
          } else {
            return callback(error);
          }
          return callback(null);
        };
      })(this));
    };

    MySQLAdapter.prototype.close = function() {
      if (this._client) {
        this._client.end();
      }
      return this._client = null;
    };

    MySQLAdapter.prototype.query = function() {
      return this._client.query.apply(this._client, arguments);
    };

    return MySQLAdapter;

  })(SQLAdapterBase);

  module.exports = function(connection) {
    return new MySQLAdapter(connection);
  };

}).call(this);

// Generated by CoffeeScript 2.3.1
var SQLAdapterBase, SQLite3Adapter, _, _propertyToSQL, _typeToSQL, async, e, sqlite3, stream, types;

try {
  sqlite3 = require('sqlite3');
} catch (error1) {
  e = error1;
  console.log('Install sqlite3 module to use this adapter');
  process.exit(1);
}

SQLAdapterBase = require('./sql_base');

types = require('../types');

async = require('async');

_ = require('lodash');

stream = require('stream');

_typeToSQL = function(property) {
  if (property.array) {
    return 'TEXT';
  }
  switch (property.type_class) {
    case types.String:
      return 'TEXT';
    case types.Number:
      return 'DOUBLE';
    case types.Boolean:
      return 'TINYINT';
    case types.Integer:
      return 'INT';
    case types.Date:
      return 'REAL';
    case types.Object:
      return 'TEXT';
    case types.Text:
      return 'TEXT';
  }
};

_propertyToSQL = function(property) {
  var type;
  type = _typeToSQL(property);
  if (type) {
    if (property.required) {
      type += ' NOT NULL';
    } else {
      type += ' NULL';
    }
    return type;
  }
};

SQLite3Adapter = (function() {
  var _processSaveError;

  //#
  // Adapter for SQLite3
  // @namespace adapter
  class SQLite3Adapter extends SQLAdapterBase {
    //#
    // Creates a SQLite3 adapter
    constructor(connection) {
      super();
      this._connection = connection;
    }

    _query(method, sql, data, callback) {
      //console.log 'SQLite3Adapter:', sql
      return this._client[method].apply(this._client, [].slice.call(arguments, 1));
    }

    _getTables(callback) {
      return this._query('all', "SELECT name FROM sqlite_master WHERE type='table'", (error, tables) => {
        if (error) {
          return callback(error);
        }
        tables = tables.map(function(table) {
          return table.name;
        });
        return callback(null, tables);
      });
    }

    _getSchema(table, callback) {
      return this._query('all', `PRAGMA table_info(\`${table}\`)`, function(error, columns) {
        var column, j, len, schema, type;
        if (error) {
          return callback(error);
        }
        schema = {};
        for (j = 0, len = columns.length; j < len; j++) {
          column = columns[j];
          type = /^varchar\((\d*)\)/i.test(column.type) ? new types.String(RegExp.$1) : /^double/i.test(column.type) ? new types.Number() : /^tinyint/i.test(column.type) ? new types.Boolean() : /^int/i.test(column.type) ? new types.Integer() : /^real/i.test(column.type) ? new types.Date() : /^text/i.test(column.type) ? new types.Object() : void 0;
          schema[column.name] = {
            type: type,
            required: column.notnull === 1
          };
        }
        return callback(null, schema);
      });
    }

    _getIndexes(table, callback) {
      return this._query('all', `PRAGMA index_list(\`${table}\`)`, (error, rows) => {
        var indexes;
        if (error) {
          return callback(error);
        }
        indexes = {};
        return async.each(rows, (row, callback) => {
          var name;
          indexes[name = row.name] || (indexes[name] = {});
          return this._query('all', `PRAGMA index_info(\`${row.name}\`)`, function(error, columns) {
            var column, j, len;
            if (error) {
              return callback(error);
            }
            for (j = 0, len = columns.length; j < len; j++) {
              column = columns[j];
              indexes[row.name][column.name] = 1;
            }
            return callback(null);
          });
        }, function(error) {
          return callback(error, indexes);
        });
      });
    }

    //# @override AdapterBase::getSchemas
    getSchemas() {
      return new Promise((resolve, reject) => {
        return async.auto({
          get_tables: (callback) => {
            return this._getTables(callback);
          },
          get_table_schemas: [
            'get_tables',
            (results,
            callback) => {
              var table_schemas;
              table_schemas = {};
              return async.each(results.get_tables,
            (table,
            callback) => {
                return this._getSchema(table,
            function(error,
            schema) {
                  if (error) {
                    return callback(error);
                  }
                  table_schemas[table] = schema;
                  return callback(null);
                });
              },
            function(error) {
                if (error) {
                  return callback(error);
                }
                return callback(null,
            table_schemas);
              });
            }
          ],
          get_indexes: [
            'get_tables',
            (results,
            callback) => {
              var all_indexes;
              all_indexes = {};
              return async.each(results.get_tables,
            (table,
            callback) => {
                return this._getIndexes(table,
            function(error,
            indexes) {
                  if (error) {
                    return callback(error);
                  }
                  all_indexes[table] = indexes;
                  return callback(null);
                });
              },
            function(error) {
                if (error) {
                  return callback(error);
                }
                return callback(null,
            all_indexes);
              });
            }
          ]
        }, function(error, results) {
          if (error) {
            return reject(error);
          } else {
            return resolve({
              tables: results.get_table_schemas,
              indexes: results.get_indexes
            });
          }
        });
      });
    }

    //# @override AdapterBase::createTable
    createTable(model, callback) {
      return new Promise((resolve, reject) => {
        var column, column_sql, integrity, j, len, model_class, property, ref, ref1, sql, tableName;
        model_class = this._connection.models[model];
        tableName = model_class.tableName;
        sql = [];
        sql.push('id INTEGER PRIMARY KEY AUTOINCREMENT');
        ref = model_class._schema;
        for (column in ref) {
          property = ref[column];
          column_sql = _propertyToSQL(property);
          if (column_sql) {
            sql.push(`"${property._dbname}" ${column_sql}`);
          }
        }
        ref1 = model_class._integrities;
        for (j = 0, len = ref1.length; j < len; j++) {
          integrity = ref1[j];
          if (integrity.type === 'child_nullify') {
            sql.push(`FOREIGN KEY ("${integrity.column}") REFERENCES "${integrity.parent.tableName}"(id) ON DELETE SET NULL`);
          } else if (integrity.type === 'child_restrict') {
            sql.push(`FOREIGN KEY ("${integrity.column}") REFERENCES "${integrity.parent.tableName}"(id) ON DELETE RESTRICT`);
          } else if (integrity.type === 'child_delete') {
            sql.push(`FOREIGN KEY ("${integrity.column}") REFERENCES "${integrity.parent.tableName}"(id) ON DELETE CASCADE`);
          }
        }
        sql = `CREATE TABLE "${tableName}" ( ${sql.join(',')} )`;
        return this._query('run', sql, (error) => {
          if (error) {
            return reject(SQLite3Adapter.wrapError('unknown error', error));
          } else {
            return resolve();
          }
        });
      });
    }

    //# @override AdapterBase::addColumn
    addColumn(model, column_property) {
      return new Promise((resolve, reject) => {
        var model_class, sql, tableName;
        model_class = this._connection.models[model];
        tableName = model_class.tableName;
        sql = `ALTER TABLE "${tableName}" ADD COLUMN "${column_property._dbname}" ${_propertyToSQL(column_property)}`;
        return this._query('run', sql, function(error) {
          if (error) {
            return reject(SQLite3Adapter.wrapError('unknown error', error));
          } else {
            return resolve();
          }
        });
      });
    }

    //# @override AdapterBase::createIndex
    createIndex(model, index) {
      return new Promise((resolve, reject) => {
        var column, columns, model_class, order, ref, sql, tableName, unique;
        model_class = this._connection.models[model];
        tableName = model_class.tableName;
        columns = [];
        ref = index.columns;
        for (column in ref) {
          order = ref[column];
          columns.push(`"${column}" ${(order === -1 ? 'DESC' : 'ASC')}`);
        }
        unique = index.options.unique ? 'UNIQUE ' : '';
        sql = `CREATE ${unique}INDEX "${index.options.name}" ON "${tableName}" (${columns.join(',')})`;
        return this._query('run', sql, (error, result) => {
          if (error) {
            return reject(SQLite3Adapter.wrapError('unknown error', error));
          } else {
            return resolve();
          }
        });
      });
    }

    //# @override AdapterBase::drop
    drop(model) {
      return new Promise((resolve, reject) => {
        var tableName;
        tableName = this._connection.models[model].tableName;
        return this._query('run', `DROP TABLE IF EXISTS "${tableName}"`, function(error) {
          if (error) {
            return reject(SQLite3Adapter.wrapError('unknown error', error));
          } else {
            return resolve();
          }
        });
      });
    }

    _getModelID(data) {
      return Number(data.id);
    }

    valueToModel(value, property) {
      if (property.type_class === types.Object || property.array) {
        try {
          return JSON.parse(value);
        } catch (error1) {
          return null;
        }
      } else if (property.type_class === types.Date) {
        return new Date(value);
      } else if (property.type_class === types.Boolean) {
        return value !== 0;
      } else {
        return value;
      }
    }

    _buildUpdateSetOfColumn(property, data, values, fields, places, insert) {
      var dbname, value;
      dbname = property._dbname;
      value = data[dbname];
      if ((value != null ? value.$inc : void 0) != null) {
        values.push(value.$inc);
        return fields.push(`"${dbname}"="${dbname}"+?`);
      } else {
        if (property.type_class === types.Date) {
          values.push(value != null ? value.getTime() : void 0);
        } else {
          values.push(value);
        }
        if (insert) {
          fields.push(`"${dbname}"`);
          return places.push('?');
        } else {
          return fields.push(`"${dbname}"=?`);
        }
      }
    }

    _buildUpdateSet(model, data, values, insert) {
      var column, fields, places, property, schema;
      schema = this._connection.models[model]._schema;
      fields = [];
      places = [];
      for (column in schema) {
        property = schema[column];
        this._buildUpdateSetOfColumn(property, data, values, fields, places, insert);
      }
      return [fields.join(','), places.join(',')];
    }

    _buildPartialUpdateSet(model, data, values) {
      var column, fields, places, property, schema, value;
      schema = this._connection.models[model]._schema;
      fields = [];
      places = [];
      for (column in data) {
        value = data[column];
        property = _.find(schema, function(item) {
          return item._dbname === column;
        });
        this._buildUpdateSetOfColumn(property, data, values, fields, places);
      }
      return [fields.join(','), places.join(',')];
    }

    //# @override AdapterBase::create
    create(model, data) {
      return new Promise((resolve, reject) => {
        var fields, places, sql, tableName, values;
        tableName = this._connection.models[model].tableName;
        values = [];
        [fields, places] = this._buildUpdateSet(model, data, values, true);
        sql = `INSERT INTO "${tableName}" (${fields}) VALUES (${places})`;
        return this._query('run', sql, values, function(error) {
          if (error) {
            _processSaveError(error, reject);
            return;
          }
          return resolve(this.lastID);
        });
      });
    }

    //# @override AdapterBase::createBulk
    createBulk(model, data) {
      return new Promise((resolve, reject) => {
        var fields, places, sql, tableName, values;
        tableName = this._connection.models[model].tableName;
        values = [];
        fields = void 0;
        places = [];
        data.forEach((item) => {
          var places_sub;
          [fields, places_sub] = this._buildUpdateSet(model, item, values, true);
          return places.push('(' + places_sub + ')');
        });
        sql = `INSERT INTO "${tableName}" (${fields}) VALUES ${places.join(',')}`;
        return this._query('run', sql, values, function(error) {
          var id;
          if (error) {
            _processSaveError(error, reject);
            return;
          }
          if (id = this.lastID) {
            id = id - data.length + 1;
            return resolve(data.map(function(item, i) {
              return id + i;
            }));
          } else {
            return reject(new Error('unexpected result'));
          }
        });
      });
    }

    //# @override AdapterBase::update
    update(model, data) {
      return new Promise((resolve, reject) => {
        var fields, sql, tableName, values;
        tableName = this._connection.models[model].tableName;
        values = [];
        [fields] = this._buildUpdateSet(model, data, values);
        values.push(data.id);
        sql = `UPDATE "${tableName}" SET ${fields} WHERE id=?`;
        return this._query('run', sql, values, function(error) {
          if (error) {
            _processSaveError(error, reject);
            return;
          }
          return resolve();
        });
      });
    }

    //# @override AdapterBase::updatePartial
    updatePartial(model, data, conditions, options) {
      return new Promise((resolve, reject) => {
        var fields, sql, tableName, values;
        tableName = this._connection.models[model].tableName;
        values = [];
        [fields] = this._buildPartialUpdateSet(model, data, values);
        sql = `UPDATE "${tableName}" SET ${fields}`;
        if (conditions.length > 0) {
          try {
            sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, values);
          } catch (error1) {
            e = error1;
            return callback(e);
          }
        }
        return this._query('run', sql, values, function(error) {
          if (error) {
            _processSaveError(error, reject);
            return;
          }
          return resolve(this.changes);
        });
      });
    }

    //# @override AdapterBase::findById
    findById(model, id, options) {
      return new Promise((resolve, reject) => {
        var select, sql, tableName;
        select = this._buildSelect(this._connection.models[model], options.select);
        tableName = this._connection.models[model].tableName;
        sql = `SELECT ${select} FROM "${tableName}" WHERE id=? LIMIT 1`;
        if (options.explain) {
          this._query('all', `EXPLAIN QUERY PLAN ${sql}`, id, function(error, result) {
            if (error) {
              reject(error);
              return;
            }
            return resolve(result);
          });
          return;
        }
        return this._query('all', sql, id, (error, result) => {
          if (error) {
            reject(SQLite3Adapter.wrapError('unknown error', error));
            return;
          }
          if ((result != null ? result.length : void 0) === 1) {
            return resolve(this._convertToModelInstance(model, result[0], options));
          } else if ((result != null ? result.length : void 0) > 1) {
            return reject(new Error('unknown error'));
          } else {
            return reject(new Error('not found'));
          }
        });
      });
    }

    _buildSqlForFind(model, conditions, options) {
      var model_class, orders, params, schema, select, sql, tableName;
      if (options.group_by || options.group_fields) {
        select = this._buildGroupFields(options.group_by, options.group_fields);
      } else {
        select = this._buildSelect(this._connection.models[model], options.select);
      }
      tableName = this._connection.models[model].tableName;
      params = [];
      sql = `SELECT ${select} FROM "${tableName}"`;
      if (conditions.length > 0) {
        sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, params);
      }
      if (options.group_by) {
        sql += ' GROUP BY ' + options.group_by.join(',');
      }
      if (options.conditions_of_group.length > 0) {
        sql += ' HAVING ' + this._buildWhere(options.group_fields, options.conditions_of_group, params);
      }
      if ((options != null ? options.orders.length : void 0) > 0) {
        model_class = this._connection.models[model];
        schema = model_class._schema;
        orders = options.orders.map(function(order) {
          var column, ref;
          if (order[0] === '-') {
            column = order.slice(1);
            order = 'DESC';
          } else {
            column = order;
            order = 'ASC';
          }
          column = ((ref = schema[column]) != null ? ref._dbname : void 0) || column;
          return `"${column}" ${order}`;
        });
        sql += ' ORDER BY ' + orders.join(',');
      }
      if ((options != null ? options.limit : void 0) != null) {
        sql += ' LIMIT ' + options.limit;
        if ((options != null ? options.skip : void 0) != null) {
          sql += ' OFFSET ' + options.skip;
        }
      } else if ((options != null ? options.skip : void 0) != null) {
        sql += ' LIMIT 2147483647 OFFSET ' + options.skip;
      }
      //console.log sql, params
      return [sql, params];
    }

    //# @override AdapterBase::find
    find(model, conditions, options) {
      return new Promise((resolve, reject) => {
        var params, sql;
        try {
          [sql, params] = this._buildSqlForFind(model, conditions, options);
        } catch (error1) {
          e = error1;
          reject(e);
          return;
        }
        if (options.explain) {
          return this._query('all', `EXPLAIN QUERY PLAN ${sql}`, params, function(error, result) {
            if (error) {
              reject(error);
              return;
            }
            return resolve(result);
          });
        }
        return this._query('all', sql, params, (error, result) => {
          if (error) {
            reject(SQLite3Adapter.wrapError('unknown error', error));
            return;
          }
          if (options.group_fields) {
            return resolve(result.map((record) => {
              return this._convertToGroupInstance(model, record, options.group_by, options.group_fields);
            }));
          } else {
            return resolve(result.map((record) => {
              return this._convertToModelInstance(model, record, options);
            }));
          }
        });
      });
    }

    //# @override AdapterBase::stream
    stream(model, conditions, options) {
      var params, readable, sql;
      try {
        [sql, params] = this._buildSqlForFind(model, conditions, options);
      } catch (error1) {
        e = error1;
        readable = new stream.Readable({
          objectMode: true
        });
        readable._read = function() {
          return readable.emit('error', e);
        };
        return readable;
      }
      readable = new stream.Readable({
        objectMode: true
      });
      readable._read = function() {};
      this._client.each(sql, params, (error, record) => {
        if (error) {
          return readable.emit('error', error);
        }
        return readable.push(this._convertToModelInstance(model, record, options));
      }, function() {
        return readable.push(null);
      });
      return readable;
    }

    //# @override AdapterBase::count
    count(model, conditions, options) {
      return new Promise((resolve, reject) => {
        var params, sql, tableName;
        params = [];
        tableName = this._connection.models[model].tableName;
        sql = `SELECT COUNT(*) AS count FROM "${tableName}"`;
        if (conditions.length > 0) {
          try {
            sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, params);
          } catch (error1) {
            e = error1;
            reject(e);
            return;
          }
        }
        if (options.group_by) {
          sql += ' GROUP BY ' + options.group_by.join(',');
          if (options.conditions_of_group.length > 0) {
            try {
              sql += ' HAVING ' + this._buildWhere(options.group_fields, options.conditions_of_group, params);
            } catch (error1) {
              e = error1;
              reject(e);
              return;
            }
          }
          sql = `SELECT COUNT(*) AS count FROM (${sql})`;
        }
        //console.log sql, params
        return this._query('all', sql, params, (error, result) => {
          if (error) {
            reject(SQLite3Adapter.wrapError('unknown error', error));
            return;
          }
          if ((result != null ? result.length : void 0) !== 1) {
            reject(new Error('unknown error'));
            return;
          }
          return resolve(Number(result[0].count));
        });
      });
    }

    //# @override AdapterBase::delete
    delete(model, conditions, callback) {
      var params, sql, tableName;
      params = [];
      tableName = this._connection.models[model].tableName;
      sql = `DELETE FROM "${tableName}"`;
      if (conditions.length > 0) {
        try {
          sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, params);
        } catch (error1) {
          e = error1;
          return callback(e);
        }
      }
      //console.log sql, params
      return this._query('run', sql, params, function(error) {
        if (error && error.code === 'SQLITE_CONSTRAINT') {
          // @ is sqlite3.Statement
          return callback(new Error('rejected'));
        }
        if (error) {
          return callback(SQLite3Adapter.wrapError('unknown error', error));
        }
        return callback(null, this.changes);
      });
    }

    //#
    // Connects to the database
    // @param {Object} settings
    // @param {String} settings.database
    // @nodejscallback
    connect(settings, callback) {
      var client;
      return client = new sqlite3.Database(settings.database, (error) => {
        if (error) {
          return callback(SQLite3Adapter.wrapError('failed to open', error));
        }
        this._client = client;
        return this._query('run', 'PRAGMA foreign_keys=ON', function(error) {
          return callback(null);
        });
      });
    }

    //# @override AdapterBase::close
    close() {
      if (this._client) {
        this._client.close();
      }
      return this._client = null;
    }

    //#
    // Exposes sqlite3 module's run method
    run() {
      return this._client.run.apply(this._client, arguments);
    }

    //#
    // Exposes sqlite3 module's all method
    all() {
      return this._client.all.apply(this._client, arguments);
    }

  };

  SQLite3Adapter.prototype.key_type = types.Integer;

  SQLite3Adapter.prototype.native_integrity = true;

  SQLite3Adapter.prototype._regexp_op = null;

  SQLite3Adapter.prototype._false_value = '0';

  _processSaveError = function(error, callback) {
    if (/no such table/.test(error.message)) {
      error = new Error('table does not exist');
    } else if (error.code === 'SQLITE_CONSTRAINT') {
      error = new Error('duplicated');
    } else {
      error = SQLite3Adapter.wrapError('unknown error', error);
    }
    return callback(error);
  };

  return SQLite3Adapter;

}).call(this);

module.exports = function(connection) {
  return new SQLite3Adapter(connection);
};

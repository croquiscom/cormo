// Generated by CoffeeScript 1.11.1
(function() {
  var ColumnProperty, Model, Promise, _, _pf_get, _pf_getChanged, _pf_getPrevious, _pf_isDirty, _pf_reset, _pf_set, _use, tableize, types, util,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  _ = require('lodash');

  Promise = require('bluebird');

  tableize = require('../util/inflector').tableize;

  types = require('../types');

  util = require('../util');

  _pf_isDirty = function() {
    return true;
  };

  _pf_getChanged = function() {
    return [];
  };

  _pf_get = function(path) {
    return util.getPropertyOfPath(this, path.split('.'));
  };

  _pf_getPrevious = function() {};

  _pf_set = function(path, value) {
    return util.setPropertyOfPath(this, path.split('.'), value);
  };

  _pf_reset = function() {};

  ColumnProperty = (function() {
    function ColumnProperty() {}

    return ColumnProperty;

  })();

  Model = (function() {
    Model.dirty_tracking = false;

    Model.archive = false;

    Model.lean_query = false;

    Model.newModel = function(connection, name, schema) {
      var NewModel, property;
      NewModel = (function(superClass) {
        extend(NewModel, superClass);

        function NewModel() {
          return NewModel.__super__.constructor.apply(this, arguments);
        }

        return NewModel;

      })(Model);
      NewModel.connection(connection, name);
      for (name in schema) {
        property = schema[name];
        NewModel.column(name, property);
      }
      return NewModel;
    };

    Model.connection = function(connection, name) {
      if (this.hasOwnProperty('_connection')) {
        throw new Error('Model::connection was called twice');
      }
      if (!name) {
        name = this.name;
      }
      connection.models[name] = this;
      connection[name] = this;
      Object.defineProperty(this, '_connection', {
        value: connection
      });
      Object.defineProperty(this, '_adapter', {
        value: connection._adapter
      });
      Object.defineProperty(this, '_associations', {
        value: {}
      });
      Object.defineProperty(this, '_validators', {
        value: []
      });
      Object.defineProperty(this, '_name', {
        value: name
      });
      Object.defineProperty(this, '_schema', {
        value: {}
      });
      Object.defineProperty(this, '_intermediate_paths', {
        value: {}
      });
      Object.defineProperty(this, '_indexes', {
        value: []
      });
      Object.defineProperty(this, '_integrities', {
        value: []
      });
      if (!this.tableName) {
        return this.tableName = tableize(name);
      }
    };

    Model._checkConnection = function() {
      if (this.hasOwnProperty('_connection')) {
        return;
      }
      if (Model._Connection.defaultConnection == null) {
        throw new Error('Create a Connection before creating a Model');
      }
      return this.connection(Model._Connection.defaultConnection);
    };

    Model._checkReady = function() {
      this._checkConnection();
      return Promise.all([this._connection._checkSchemaApplied(), this._connection._promise_connection]);
    };

    Model._getKeyType = function(target_connection) {
      if (target_connection == null) {
        target_connection = this._connection;
      }
      if (this._connection === target_connection && target_connection._adapter.key_type_internal) {
        return new target_connection._adapter.key_type_internal;
      } else {
        return new target_connection._adapter.key_type;
      }
    };

    Model.column = function(path, property) {
      var i, j, parts, ref, subcolumn, subproperty, type;
      this._checkConnection();
      if (_.isPlainObject(property) && (!property.type || property.type.type)) {
        for (subcolumn in property) {
          subproperty = property[subcolumn];
          this.column(path + '.' + subcolumn, subproperty);
        }
        return;
      }
      if (this._schema.hasOwnProperty(path)) {
        if ((property != null ? property.required : void 0) != null) {
          this._schema[path].required = property.required;
        }
        return;
      }
      if (!_.isPlainObject(property)) {
        property = {
          type: property
        };
      }
      if (Array.isArray(property.type)) {
        property.array = true;
        property.type = property.type[0];
      }
      type = types._toCORMOType(property.type);
      if (type.constructor === types.RecordID) {
        type = this._getKeyType(property.connection);
        property.record_id = true;
      }
      if (type.constructor === types.GeoPoint && !this._adapter.support_geopoint) {
        throw new Error('this adapter does not support GeoPoint type');
      }
      if (type.constructor === types.String && type.length && !this._adapter.support_string_type_with_length) {
        throw new Error('this adapter does not support String type with length');
      }
      parts = path.split('.');
      for (i = j = 0, ref = parts.length - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        this._intermediate_paths[parts.slice(0, +i + 1 || 9e9).join('.')] = 1;
      }
      property.type = type;
      property.type_class = type.constructor;
      property._parts = path.split('.');
      property._dbname = path.replace(/\./g, '_');
      this._schema[path] = property;
      if (property.unique) {
        this._indexes.push({
          columns: _.zipObject([property._dbname], [1]),
          options: {
            name: property._dbname,
            unique: true,
            required: property.required
          }
        });
      }
      return this._connection._schema_changed = true;
    };

    Model.index = function(columns, options) {
      this._checkConnection();
      options || (options = {});
      if (!options.name) {
        options.name = Object.keys(columns).join('_');
      }
      this._indexes.push({
        columns: columns,
        options: options
      });
      return this._connection._schema_changed = true;
    };

    Model.drop = function(callback) {
      return this._connection._promise_connection.then((function(_this) {
        return function() {
          return _this._adapter.dropAsync(_this._name);
        };
      })(this))["finally"]((function(_this) {
        return function() {
          return _this._connection._schema_changed = true;
        };
      })(this)).nodeify(util.bindDomain(callback));
    };

    Model.build = function(data) {
      return new this(data);
    };

    function Model(data) {
      var adapter, column, ctor, id, j, last, len, obj, parts, path, property, ref, ref1, ref2, schema, selected_columns, selected_columns_raw, value;
      data = data || {};
      ctor = this.constructor;
      schema = ctor._schema;
      adapter = ctor._adapter;
      Object.defineProperty(this, '_prev_attributes', {
        writable: true,
        value: {}
      });
      if (ctor.dirty_tracking) {
        Object.defineProperty(this, '_attributes', {
          value: {}
        });
        Object.defineProperty(this, '_intermediates', {
          value: {}
        });
        ref = Object.keys(ctor._intermediate_paths).sort();
        for (j = 0, len = ref.length; j < len; j++) {
          path = ref[j];
          ref1 = util.getLeafOfPath(this, path), obj = ref1[0], last = ref1[1];
          this._intermediates[path] = {};
          this._defineProperty(obj, last, path, false);
        }
        for (column in schema) {
          property = schema[column];
          ref2 = util.getLeafOfPath(this, property._parts), obj = ref2[0], last = ref2[1];
          this._defineProperty(obj, last, column, false);
        }
      } else {
        Object.defineProperty(this, 'isDirty', {
          value: _pf_isDirty
        });
        Object.defineProperty(this, 'getChanged', {
          value: _pf_getChanged
        });
        Object.defineProperty(this, 'get', {
          value: _pf_get
        });
        Object.defineProperty(this, 'getPrevious', {
          value: _pf_getPrevious
        });
        Object.defineProperty(this, 'set', {
          value: _pf_set
        });
        Object.defineProperty(this, 'reset', {
          value: _pf_reset
        });
      }
      if (id = arguments[1]) {
        selected_columns = arguments[2];
        selected_columns_raw = arguments[3];
        adapter.setValuesFromDB(this, data, schema, selected_columns);
        ctor._collapseNestedNulls(this, selected_columns_raw, ctor.dirty_tracking ? this._intermediates : void 0);
        Object.defineProperty(this, 'id', {
          configurable: false,
          enumerable: true,
          writable: false,
          value: id
        });
        this._runCallbacks('find', 'after');
      } else {
        for (column in schema) {
          property = schema[column];
          parts = property._parts;
          value = util.getPropertyOfPath(data, parts);
          if (value === void 0) {
            value = null;
          }
          util.setPropertyOfPath(this, parts, value);
        }
        ctor._collapseNestedNulls(this, null, ctor.dirty_tracking ? this._intermediates : void 0);
        Object.defineProperty(this, 'id', {
          configurable: true,
          enumerable: true,
          writable: false,
          value: null
        });
      }
      this._runCallbacks('initialize', 'after');
    }

    Model._collapseNestedNulls = function(instance, selected_columns_raw, intermediates) {
      var has_non_null, j, key, last, len, obj, path, ref, ref1, ref2, results, value;
      ref = Object.keys(this._intermediate_paths);
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        path = ref[j];
        if (selected_columns_raw && selected_columns_raw.indexOf(path) === -1) {
          continue;
        }
        if (intermediates) {
          obj = intermediates;
          last = path;
        } else {
          ref1 = util.getLeafOfPath(instance, path), obj = ref1[0], last = ref1[1];
        }
        has_non_null = false;
        ref2 = obj[last];
        for (key in ref2) {
          value = ref2[key];
          if (value != null) {
            has_non_null = true;
          }
        }
        if (!has_non_null) {
          results.push(obj[last] = null);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Model.prototype._defineProperty = function(object, key, path, enumerable) {
      return Object.defineProperty(object, key, {
        configurable: true,
        enumerable: enumerable,
        get: (function(_this) {
          return function() {
            return _this.get(path);
          };
        })(this),
        set: (function(_this) {
          return function(value) {
            return _this.set(path, value);
          };
        })(this)
      });
    };

    Model.prototype.isDirty = function() {
      return Object.keys(this._prev_attributes).length > 0;
    };

    Model.prototype.getChanged = function() {
      return Object.keys(this._prev_attributes);
    };

    Model.prototype.get = function(path) {
      if (this._intermediates.hasOwnProperty(path)) {
        return this._intermediates[path];
      } else {
        return util.getPropertyOfPath(this._attributes, path);
      }
    };

    Model.prototype.getPrevious = function(path) {
      return this._prev_attributes[path];
    };

    Model.prototype.set = function(path, value) {
      var k, last, obj, parts, prev_value, ref, ref1, results, results1, v;
      if (this._intermediates.hasOwnProperty(path)) {
        obj = this._intermediates[path];
        for (k in obj) {
          obj[k] = void 0;
        }
        results = [];
        for (k in value) {
          v = value[k];
          results.push(obj[k] = v);
        }
        return results;
      } else {
        parts = path.split('.');
        prev_value = util.getPropertyOfPath(this._attributes, parts);
        if (prev_value === value) {
          return;
        }
        if (!this._prev_attributes.hasOwnProperty(path)) {
          this._prev_attributes[path] = prev_value;
        }
        ref = util.getLeafOfPath(this, parts), obj = ref[0], last = ref[1];
        this._defineProperty(obj, last, path, true);
        util.setPropertyOfPath(this._attributes, parts, value);
        results1 = [];
        while (parts.length > 1) {
          parts.pop();
          ref1 = util.getLeafOfPath(this, parts), obj = ref1[0], last = ref1[1];
          results1.push(this._defineProperty(obj, last, parts.join('.'), true));
        }
        return results1;
      }
    };

    Model.prototype.reset = function() {
      var path, ref, value;
      ref = this._prev_attributes;
      for (path in ref) {
        value = ref[path];
        this.set(path, value);
      }
      return this._prev_attributes = {};
    };

    Model.prototype.destroy = function(callback) {
      this._runCallbacks('destroy', 'before');
      return Promise.resolve().then((function(_this) {
        return function() {
          if (_this.id) {
            return _this.constructor["delete"]({
              id: _this.id
            });
          }
        };
      })(this))["finally"]((function(_this) {
        return function() {
          return _this._runCallbacks('destroy', 'after');
        };
      })(this)).nodeify(util.bindDomain(callback));
    };

    Model.deleteAll = function(callback) {
      return this["delete"]().nodeify(callback);
    };

    Model.hasMany = function(target_model_or_column, options) {
      this._checkConnection();
      return this._connection.addAssociation({
        type: 'hasMany',
        this_model: this,
        target_model_or_column: target_model_or_column,
        options: options
      });
    };

    Model.hasOne = function(target_model_or_column, options) {
      this._checkConnection();
      return this._connection.addAssociation({
        type: 'hasOne',
        this_model: this,
        target_model_or_column: target_model_or_column,
        options: options
      });
    };

    Model.belongsTo = function(target_model_or_column, options) {
      this._checkConnection();
      return this._connection.addAssociation({
        type: 'belongsTo',
        this_model: this,
        target_model_or_column: target_model_or_column,
        options: options
      });
    };

    Model.inspect = function(depth) {
      var schema;
      schema = Object.keys(this._schema || {}).sort().map((function(_this) {
        return function(column) {
          return column + ": " + _this._schema[column].type;
        };
      })(this)).join(', ');
      return '\u001b[36m' + ("[Model: " + this.name + "(") + '\u001b[90m' + schema + '\u001b[36m' + ")]" + '\u001b[39m';
    };

    return Model;

  })();

  _use = function(file) {
    var MixClass;
    MixClass = require("./" + file);
    _.extend(Model, MixClass);
    return _.extend(Model.prototype, MixClass.prototype);
  };

  _use('query');

  _use('callback');

  _use('timestamp');

  _use('persistence');

  _use('validate');

  _use('cache');

  module.exports = Model;

}).call(this);

// Generated by CoffeeScript 2.3.1
var ModelPersistenceMixin, Promise, _, inflector, util;

_ = require('lodash');

inflector = require('../util/inflector');

Promise = require('bluebird');

util = require('../util');

//#
// Model persistence
// @namespace model
ModelPersistenceMixin = function(Base) {
  return class extends Base {
    //#
    // Creates a record and saves it to the database
    // 'Model.create(data, callback)' is the same as 'Model.build(data).save(callback)'
    // @param {Object} [data={}]
    // @param {Object} [options]
    // @param {Boolean} [options.skip_log=false]
    // @return {Model} created record
    // @promise
    // @nodejscallback
    static create(data, options, callback) {
      if (typeof data === 'function') {
        callback = data;
        data = {};
        options = {};
      } else if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      return this._checkReady().then(() => {
        return this.build(data).save(options);
      }).nodeify(util.bindDomain(callback));
    }

    //#
    // Creates multiple records and saves them to the database.
    // @param {Array<Object>} data
    // @return {Array<Model>} created records
    // @promise
    // @nodejscallback
    static createBulk(data, callback) {
      return this._checkReady().then(async() => {
        var promises, records;
        if (!Array.isArray(data)) {
          return Promise.reject(new Error('data is not an array'));
        }
        if (data.length === 0) {
          return Promise.resolve([]);
        }
        records = data.map((item) => {
          return this.build(item);
        });
        promises = records.map(function(record) {
          return record.validate();
        });
        await Promise.all(promises);
        records.forEach(function(record) {
          return record._runCallbacks('save', 'before');
        });
        records.forEach(function(record) {
          return record._runCallbacks('create', 'before');
        });
        try {
          return (await this._createBulk(records));
        } finally {
          records.forEach(function(record) {
            return record._runCallbacks('create', 'after');
          });
          records.forEach(function(record) {
            return record._runCallbacks('save', 'after');
          });
        }
      }).nodeify(util.bindDomain(callback));
    }

    static _buildSaveDataColumn(data, model, column, property, allow_null) {
      var adapter, parts, value;
      adapter = this._adapter;
      parts = property._parts;
      value = util.getPropertyOfPath(model, parts);
      value = adapter.valueToDB(value, column, property);
      if (allow_null || value !== void 0) {
        if (adapter.support_nested) {
          return util.setPropertyOfPath(data, parts, value);
        } else {
          return data[property._dbname] = value;
        }
      }
    }

    _buildSaveData() {
      var column, ctor, data, property, schema;
      data = {};
      ctor = this.constructor;
      schema = ctor._schema;
      for (column in schema) {
        property = schema[column];
        ctor._buildSaveDataColumn(data, this, column, property);
      }
      if (this.id != null) {
        data.id = ctor._adapter.idToDB(this.id);
      }
      return data;
    }

    async _create(options) {
      var ctor, data, foreign_key, id, promises;
      data = this._buildSaveData();
      ctor = this.constructor;
      if (!(options != null ? options.skip_log : void 0)) {
        ctor._connection.log(ctor._name, 'create', data);
      }
      id = (await ctor._adapter.create(ctor._name, data));
      Object.defineProperty(this, 'id', {
        configurable: false,
        enumerable: true,
        writable: false,
        value: id
      });
      // save sub objects of each association
      foreign_key = inflector.foreign_key(ctor._name);
      promises = Object.keys(ctor._associations).map((column) => {
        var sub_promises;
        sub_promises = (this['__cache_' + column] || []).map(function(sub) {
          sub[foreign_key] = id;
          return sub.save();
        });
        return Promise.all(sub_promises);
      });
      try {
        await Promise.all(promises);
      } catch (error1) {

      }
      return this._prev_attributes = {};
    }

    static async _createBulk(records) {
      var data_array, error, ids;
      error = void 0;
      data_array = records.map(function(record) {
        var data, e;
        try {
          data = record._buildSaveData();
        } catch (error1) {
          e = error1;
          error = e;
        }
        return data;
      });
      if (error) {
        throw error;
      }
      this._connection.log(this._name, 'createBulk', data_array);
      ids = (await this._adapter.createBulk(this._name, data_array));
      records.forEach(function(record, i) {
        return Object.defineProperty(record, 'id', {
          configurable: false,
          enumerable: true,
          writable: false,
          value: ids[i]
        });
      });
      return records;
    }

    _update(options) {
      var adapter, ctor, data, e, path, schema;
      ctor = this.constructor;
      if (ctor.dirty_tracking) {
        // update changed values only
        if (!this.isDirty()) {
          return Promise.resolve();
        }
        data = {};
        adapter = ctor._adapter;
        schema = ctor._schema;
        try {
          for (path in this._prev_attributes) {
            ctor._buildSaveDataColumn(data, this._attributes, path, schema[path], true);
          }
        } catch (error1) {
          e = error1;
          return Promise.reject(e);
        }
        if (!(options != null ? options.skip_log : void 0)) {
          ctor._connection.log(ctor._name, 'update', data);
        }
        return adapter.updatePartialAsync(ctor._name, data, {
          id: this.id
        }, {}).then(() => {
          return this._prev_attributes = {};
        });
      } else {
        try {
          // update all
          data = this._buildSaveData();
        } catch (error1) {
          e = error1;
          return Promise.reject(e);
        }
        if (!(options != null ? options.skip_log : void 0)) {
          ctor._connection.log(ctor._name, 'update', data);
        }
        return ctor._adapter.update(ctor._name, data).then(() => {
          return this._prev_attributes = {};
        });
      }
    }

    //#
    // Saves data to the database
    // @param {Object} [options]
    // @param {Boolean} [options.validate=true]
    // @param {Boolean} [options.skip_log=false]
    // @return {Model} this
    // @promise
    // @nodejscallback
    save(options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      return this.constructor._checkReady().then(async() => {
        if ((options != null ? options.validate : void 0) !== false) {
          return this.validate().then(() => {
            return this.save(_.extend({}, options, {
              validate: false
            }));
          });
        }
        this._runCallbacks('save', 'before');
        if (this.id) {
          this._runCallbacks('update', 'before');
          return this._update(options).finally(() => {
            this._runCallbacks('update', 'after');
            return this._runCallbacks('save', 'after');
          });
        } else {
          this._runCallbacks('create', 'before');
          try {
            return (await this._create(options));
          } finally {
            this._runCallbacks('create', 'after');
            this._runCallbacks('save', 'after');
          }
        }
      }).then(() => {
        return Promise.resolve(this);
      }).nodeify(util.bindDomain(callback));
    }

  };
};

module.exports = ModelPersistenceMixin;

// Generated by CoffeeScript 1.12.5
(function() {
  var Connection, EventEmitter, Model, Promise, Toposort, _, _use, bindDomain, deasync, inspect, redis,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;

  Model = require('../model');

  _ = require('lodash');

  bindDomain = require('../util').bindDomain;

  Promise = require('bluebird');

  Toposort = require('toposort-class');

  try {
    redis = require('redis');
  } catch (error1) {}

  inspect = require('util').inspect;

  try {
    deasync = require('deasync');
  } catch (error1) {}

  Connection = (function(superClass) {
    extend(Connection, superClass);

    function Connection(adapter_name, settings) {
      var redis_cache;
      if (settings.is_default !== false) {
        Connection.defaultConnection = this;
      }
      redis_cache = settings.redis_cache || {};
      this._redis_cache_settings = redis_cache;
      this.connected = false;
      this.models = {};
      this._pending_associations = [];
      this._schema_changed = false;
      this._adapter = Promise.promisifyAll(require(__dirname + '/../adapters/' + adapter_name)(this));
      this._promise_connection = this._adapter.connectAsync(settings).then((function(_this) {
        return function() {
          return _this.connected = true;
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          _this._adapter = null;
          return Promise.reject(error);
        };
      })(this));
      Object.defineProperty(this, 'adapter', {
        get: function() {
          return this._adapter;
        }
      });
    }

    Connection.prototype.close = function() {
      if (Connection.defaultConnection === this) {
        Connection.defaultConnection = null;
      }
      this._adapter.close();
      return this._adapter = null;
    };

    Connection.prototype.model = function(name, schema) {
      return Model.newModel(this, name, schema);
    };

    Connection.prototype._checkSchemaApplied = function() {
      this._initializeModels();
      if (!this._applying_schemas && !this._schema_changed) {
        return Promise.resolve();
      }
      return this.applySchemas();
    };

    Connection.prototype._initializeModels = function() {
      var model, modelClass, ref;
      ref = this.models;
      for (model in ref) {
        modelClass = ref[model];
        if (modelClass.initialize && !modelClass._initialize_called) {
          modelClass.initialize();
          modelClass._initializeModels = true;
        }
      }
    };

    Connection.prototype._checkArchive = function() {
      var _Archive, model, modelClass, ref;
      ref = this.models;
      for (model in ref) {
        modelClass = ref[model];
        if (modelClass.archive && !modelClass._connection.models.hasOwnProperty('_Archive')) {
          _Archive = (function(superClass1) {
            extend(_Archive, superClass1);

            function _Archive() {
              return _Archive.__super__.constructor.apply(this, arguments);
            }

            _Archive.connection(modelClass._connection);

            _Archive.archive = false;

            _Archive.column('model', String);

            _Archive.column('data', Object);

            return _Archive;

          })(Model);
        }
      }
    };

    Connection.prototype._getModelNamesByAssociationOrder = function() {
      var t;
      t = new Toposort();
      Object.keys(this.models).forEach((function(_this) {
        return function(model) {
          var association, modelClass, name, ref, ref1, results;
          t.add(model, []);
          modelClass = _this.models[model];
          ref = modelClass._associations;
          results = [];
          for (name in ref) {
            association = ref[name];
            if (association.target_model._connection !== _this) {
              continue;
            }
            if (association.target_model === modelClass) {
              continue;
            }
            if ((ref1 = association.type) === 'hasMany' || ref1 === 'hasOne') {
              results.push(t.add(association.target_model._name, model));
            } else if (association.type === 'belongsTo') {
              results.push(t.add(model, association.target_model._name));
            } else {
              results.push(void 0);
            }
          }
          return results;
        };
      })(this));
      return t.sort();
    };

    Connection.prototype.applySchemas = function(options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      } else if (!options) {
        options = {};
      }
      return Promise.resolve().then((function(_this) {
        return function() {
          _this._initializeModels();
          if (!_this._schema_changed) {
            return;
          }
          _this._applyAssociations();
          if (!_this._applying_schemas) {
            _this._applying_schemas = true;
            _this._checkArchive();
            if (options.verbose) {
              console.log('Applying schemas');
            }
            _this._promise_schema_applied = _this._promise_connection.then(function() {
              return _this._adapter.getSchemasAsync().tap(function(current) {
                var add_columns_commands, column, model, modelClass, property, ref, ref1, ref2, ref3, ref4, ref5;
                add_columns_commands = [];
                ref = _this.models;
                for (model in ref) {
                  modelClass = ref[model];
                  if (!((ref1 = current.tables) != null ? ref1[modelClass.tableName] : void 0) || ((ref2 = current.tables) != null ? ref2[modelClass.tableName] : void 0) === 'NO SCHEMA') {
                    continue;
                  }
                  ref3 = modelClass._schema;
                  for (column in ref3) {
                    property = ref3[column];
                    if (!((ref4 = current.tables) != null ? (ref5 = ref4[modelClass.tableName]) != null ? ref5[property._dbname] : void 0 : void 0)) {
                      if (options.verbose) {
                        console.log("Adding column " + column + " to " + modelClass.tableName);
                      }
                      add_columns_commands.push(_this._adapter.addColumnAsync(model, property));
                    }
                  }
                }
                return Promise.all(add_columns_commands);
              }).tap(function(current) {
                var model, modelClass, ref, tables_commands;
                tables_commands = [];
                ref = _this.models;
                for (model in ref) {
                  modelClass = ref[model];
                  if (!current.tables[modelClass.tableName]) {
                    if (options.verbose) {
                      console.log("Creating table " + modelClass.tableName);
                    }
                    tables_commands.push(_this._adapter.createTableAsync(model));
                  }
                }
                return Promise.all(tables_commands);
              }).tap(function(current) {
                var i, index, indexes_commands, len, model, modelClass, ref, ref1, ref2, ref3;
                indexes_commands = [];
                ref = _this.models;
                for (model in ref) {
                  modelClass = ref[model];
                  ref1 = modelClass._indexes;
                  for (i = 0, len = ref1.length; i < len; i++) {
                    index = ref1[i];
                    if (!((ref2 = current.indexes) != null ? (ref3 = ref2[modelClass.tableName]) != null ? ref3[index.options.name] : void 0 : void 0)) {
                      if (options.verbose) {
                        console.log("Creating index on " + modelClass.tableName + " " + (Object.keys(index.columns)));
                      }
                      indexes_commands.push(_this._adapter.createIndexAsync(model, index));
                    }
                  }
                }
                return Promise.all(indexes_commands);
              }).tap(function(current) {
                var current_foreign_key, foreign_keys_commands, i, integrity, len, model, modelClass, ref, ref1, ref2, ref3, type;
                foreign_keys_commands = [];
                ref = _this.models;
                for (model in ref) {
                  modelClass = ref[model];
                  ref1 = modelClass._integrities;
                  for (i = 0, len = ref1.length; i < len; i++) {
                    integrity = ref1[i];
                    type = '';
                    if (integrity.type === 'child_nullify') {
                      type = 'nullify';
                    } else if (integrity.type === 'child_restrict') {
                      type = 'restrict';
                    } else if (integrity.type === 'child_delete') {
                      type = 'delete';
                    }
                    if (type) {
                      current_foreign_key = (ref2 = current.foreign_keys) != null ? (ref3 = ref2[modelClass.tableName]) != null ? ref3[integrity.column] : void 0 : void 0;
                      if (!(current_foreign_key && current_foreign_key === integrity.parent.tableName)) {
                        if (options.verbose) {
                          console.log("Adding foreign key " + modelClass.tableName + "." + integrity.column + " to " + integrity.parent.tableName);
                        }
                        foreign_keys_commands.push([model, integrity.column, type, integrity.parent]);
                      }
                    }
                  }
                }
                return Promise.each(foreign_keys_commands, function(args) {
                  return _this._adapter.createForeignKeyAsync.apply(_this._adapter, args);
                });
              })["finally"](function() {
                if (options.verbose) {
                  console.log('Applying schemas done');
                }
                _this._applying_schemas = false;
                return _this._schema_changed = false;
              });
            });
          }
          return _this._promise_schema_applied;
        };
      })(this)).nodeify(bindDomain(callback));
    };

    Connection.prototype.applySchemasSync = typeof deasync === "function" ? deasync(Connection.prototype.applySchemas) : void 0;

    Connection.prototype.dropAllModels = function(callback) {
      var current;
      current = Promise.resolve();
      return Promise.all(this._getModelNamesByAssociationOrder().map((function(_this) {
        return function(model) {
          return current = current.then(function() {
            return _this.models[model].drop();
          });
        };
      })(this))).nodeify(bindDomain(callback));
    };

    Connection.prototype.log = function(model, type, data) {};

    Connection.prototype._connectRedisCache = function() {
      var client, settings;
      if (this._redis_cache_client) {
        return Promise.resolve(this._redis_cache_client);
      } else if (!redis) {
        return Promise.reject(new Error('cache needs Redis'));
      } else {
        settings = this._redis_cache_settings;
        this._redis_cache_client = client = settings.client || (redis.createClient(settings.port || 6379, settings.host || '127.0.0.1'));
        if (settings.database != null) {
          client.select(settings.database);
          client.once('connect', function() {
            client.send_anyways = true;
            client.select(settings.database);
            return client.send_anyways = false;
          });
        }
        return Promise.resolve(client);
      }
    };

    Connection.prototype.inspect = function(depth) {
      return inspect(this.models);
    };

    return Connection;

  })(EventEmitter);

  _use = function(file) {
    var MixClass;
    MixClass = require("./" + file);
    _.extend(Connection, MixClass);
    return _.extend(Connection.prototype, MixClass.prototype);
  };

  _use('association');

  _use('manipulate');

  Model._Connection = Connection;

  module.exports = Connection;

}).call(this);

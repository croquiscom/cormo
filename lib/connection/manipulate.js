// Generated by CoffeeScript 2.3.1
var ConnectionManipulateMixin, Promise, inflector, types;

inflector = require('../util/inflector');

Promise = require('bluebird');

types = require('../types');

//#
// Manipulate data
// @namespace connection
ConnectionManipulateMixin = function(Base) {
  return class extends Base {
    _manipulateCreate(model, data) {
      model = inflector.camelize(model);
      if (!this.models[model]) {
        return Promise.reject(new Error(`model ${model} does not exist`));
      }
      model = this.models[model];
      return model.create(data, {
        skip_log: true
      });
    }

    _manipulateDelete(model, data) {
      model = inflector.camelize(model);
      if (!this.models[model]) {
        return Promise.reject(new Error(`model ${model} does not exist`));
      }
      model = this.models[model];
      return model.where(data).delete({
        skip_log: true
      });
    }

    _manipulateDeleteAllModels() {
      return Promise.each(Object.keys(this.models), (model) => {
        if (model === '_Archive') {
          return;
        }
        model = this.models[model];
        return model.where().delete({
          skip_log: true
        });
      });
    }

    _manipulateDropModel(model) {
      model = inflector.camelize(model);
      if (!this.models[model]) {
        return Promise.reject(new Error(`model ${model} does not exist`));
      }
      model = this.models[model];
      return model.drop();
    }

    _manipulateDropAllModels() {
      return this.dropAllModels();
    }

    _manipulateFind(model, data) {
      model = inflector.camelize(inflector.singularize(model));
      if (!this.models[model]) {
        return Promise.reject(new Error(`model ${model} does not exist`));
      }
      model = this.models[model];
      return model.where(data).exec({
        skip_log: true
      });
    }

    _manipulateConvertIds(id_to_record_map, model, data) {
      var column, property, record, ref, results;
      model = inflector.camelize(model);
      if (!this.models[model]) {
        return;
      }
      model = this.models[model];
      ref = model._schema;
      results = [];
      for (column in ref) {
        property = ref[column];
        if (property.record_id && data.hasOwnProperty(column)) {
          if (property.array && Array.isArray(data[column])) {
            results.push(data[column] = data[column].map(function(value) {
              var record;
              record = id_to_record_map[value];
              if (record) {
                return record.id;
              } else {
                return value;
              }
            }));
          } else {
            record = id_to_record_map[data[column]];
            if (record) {
              results.push(data[column] = record.id);
            } else {
              results.push(void 0);
            }
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    //#
    // Manipulate data
    // @param {Array<Object>} commands
    // @return {Object}
    // @promise
    // @nodejscallback
    manipulate(commands, callback) {
      this.log('<conn>', 'manipulate', commands);
      return this._checkSchemaApplied().then(() => {
        var id_to_record_map;
        id_to_record_map = {};
        if (!Array.isArray(commands)) {
          commands = [commands];
        }
        return Promise.each(commands, (command) => {
          var data, id, key, model;
          if (typeof command === 'object') {
            key = Object.keys(command);
            if (key.length === 1) {
              key = key[0];
              data = command[key];
            } else {
              key = void 0;
            }
          } else if (typeof command === 'string') {
            key = command;
          }
          if (!key) {
            return Promise.reject(new Error('invalid command: ' + JSON.stringify(command)));
          } else if (key.substr(0, 7) === 'create_') {
            model = key.substr(7);
            id = data.id;
            delete data.id;
            this._manipulateConvertIds(id_to_record_map, model, data);
            return this._manipulateCreate(model, data).then(function(record) {
              if (id) {
                return id_to_record_map[id] = record;
              }
            });
          } else if (key.substr(0, 7) === 'delete_') {
            model = key.substr(7);
            return this._manipulateDelete(model, data);
          } else if (key === 'deleteAll') {
            return this._manipulateDeleteAllModels();
          } else if (key.substr(0, 5) === 'drop_') {
            model = key.substr(5);
            return this._manipulateDropModel(model);
          } else if (key === 'dropAll') {
            return this._manipulateDropAllModels();
          } else if (key.substr(0, 5) === 'find_') {
            model = key.substr(5);
            id = data.id;
            delete data.id;
            if (!id) {
              return;
            }
            return this._manipulateFind(model, data).then(function(records) {
              return id_to_record_map[id] = records;
            });
          } else {
            return Promise.reject(new Error('unknown command: ' + key));
          }
        }).then(function() {
          return id_to_record_map;
        });
      }).nodeify(callback);
    }

  };
};

module.exports = ConnectionManipulateMixin;

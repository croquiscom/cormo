// Generated by CoffeeScript 1.12.5
(function() {
  var ConnectionAssociation, Promise, _, bindDomain, inflector, types;

  _ = require('lodash');

  bindDomain = require('../util').bindDomain;

  inflector = require('../util/inflector');

  Promise = require('bluebird');

  types = require('../types');

  ConnectionAssociation = (function() {
    function ConnectionAssociation() {}

    ConnectionAssociation.prototype._hasMany = function(this_model, target_model, options) {
      var column, columnCache, columnGetter, foreign_key, integrity;
      if (options != null ? options.foreign_key : void 0) {
        foreign_key = options.foreign_key;
      } else if (options != null ? options.as : void 0) {
        foreign_key = options.as + '_id';
      } else {
        foreign_key = inflector.foreign_key(this_model._name);
      }
      target_model.column(foreign_key, {
        type: types.RecordID,
        connection: this_model._connection
      });
      integrity = (options != null ? options.integrity : void 0) || 'ignore';
      target_model._integrities.push({
        type: 'child_' + integrity,
        column: foreign_key,
        parent: this_model
      });
      this_model._integrities.push({
        type: 'parent_' + integrity,
        column: foreign_key,
        child: target_model
      });
      column = (options != null ? options.as : void 0) || inflector.tableize(target_model._name);
      columnCache = '__cache_' + column;
      columnGetter = '__getter_' + column;
      this_model._associations[column] = {
        type: 'hasMany',
        target_model: target_model,
        foreign_key: foreign_key
      };
      return Object.defineProperty(this_model.prototype, column, {
        get: function() {
          var getter;
          if (!this.hasOwnProperty(columnGetter)) {
            getter = function(reload, callback) {
              if (typeof reload === 'function') {
                callback = reload;
                reload = false;
              }
              return Promise.resolve().then(function() {
                var self;
                self = getter.__scope;
                if ((!self[columnCache] || reload) && self.id) {
                  return target_model.where(_.zipObject([foreign_key], [self.id])).exec().then(function(records) {
                    self[columnCache] = records;
                    return Promise.resolve(records);
                  });
                } else {
                  return Promise.resolve(self[columnCache] || []);
                }
              }).nodeify(callback);
            };
            getter.build = function(data) {
              var new_object, self;
              self = getter.__scope;
              new_object = new target_model(data);
              new_object[foreign_key] = self.id;
              if (!self[columnCache]) {
                self[columnCache] = [];
              }
              self[columnCache].push(new_object);
              return new_object;
            };
            getter.__scope = this;
            Object.defineProperty(this, columnCache, {
              value: null,
              writable: true
            });
            Object.defineProperty(this, columnGetter, {
              value: getter
            });
          }
          return this[columnGetter];
        }
      });
    };

    ConnectionAssociation.prototype._hasOne = function(this_model, target_model, options) {
      var column, columnCache, columnGetter, foreign_key, integrity;
      if (options != null ? options.foreign_key : void 0) {
        foreign_key = options.foreign_key;
      } else if (options != null ? options.as : void 0) {
        foreign_key = options.as + '_id';
      } else {
        foreign_key = inflector.foreign_key(this_model._name);
      }
      target_model.column(foreign_key, {
        type: types.RecordID,
        connection: this_model._connection
      });
      integrity = (options != null ? options.integrity : void 0) || 'ignore';
      target_model._integrities.push({
        type: 'child_' + integrity,
        column: foreign_key,
        parent: this_model
      });
      this_model._integrities.push({
        type: 'parent_' + integrity,
        column: foreign_key,
        child: target_model
      });
      column = (options != null ? options.as : void 0) || inflector.underscore(target_model._name);
      columnCache = '__cache_' + column;
      columnGetter = '__getter_' + column;
      this_model._associations[column] = {
        type: 'hasOne',
        target_model: target_model
      };
      return Object.defineProperty(this_model.prototype, column, {
        get: function() {
          var getter;
          if (!this.hasOwnProperty(columnGetter)) {
            getter = function(reload, callback) {
              if (typeof reload === 'function') {
                callback = reload;
                reload = false;
              }
              return Promise.resolve().then(function() {
                var self;
                self = getter.__scope;
                if ((!self[columnCache] || reload) && self.id) {
                  return target_model.where(_.zipObject([foreign_key], [self.id])).exec().then(function(records) {
                    var record;
                    if (records.length > 1) {
                      return Promise.reject(new Error('integrity error'));
                    }
                    record = records.length === 0 ? null : records[0];
                    self[columnCache] = record;
                    return Promise.resolve(record);
                  });
                } else {
                  return Promise.resolve(self[columnCache]);
                }
              }).nodeify(callback);
            };
            getter.__scope = this;
            Object.defineProperty(this, columnCache, {
              value: null,
              writable: true
            });
            Object.defineProperty(this, columnGetter, {
              value: getter
            });
          }
          return this[columnGetter];
        }
      });
    };

    ConnectionAssociation.prototype._belongsTo = function(this_model, target_model, options) {
      var column, columnCache, columnGetter, foreign_key;
      if (options != null ? options.foreign_key : void 0) {
        foreign_key = options.foreign_key;
      } else if (options != null ? options.as : void 0) {
        foreign_key = options.as + '_id';
      } else {
        foreign_key = inflector.foreign_key(target_model._name);
      }
      this_model.column(foreign_key, {
        type: types.RecordID,
        connection: target_model._connection,
        required: options != null ? options.required : void 0
      });
      column = (options != null ? options.as : void 0) || inflector.underscore(target_model._name);
      columnCache = '__cache_' + column;
      columnGetter = '__getter_' + column;
      this_model._associations[column] = {
        type: 'belongsTo',
        target_model: target_model
      };
      return Object.defineProperty(this_model.prototype, column, {
        get: function() {
          var getter;
          if (!this.hasOwnProperty(columnGetter)) {
            getter = function(reload, callback) {
              if (typeof reload === 'function') {
                callback = reload;
                reload = false;
              }
              return Promise.resolve().then(function() {
                var self;
                self = getter.__scope;
                if ((!self[columnCache] || reload) && self[foreign_key]) {
                  return target_model.find(self[foreign_key]).exec().then(function(record) {
                    self[columnCache] = record;
                    return Promise.resolve(record);
                  });
                } else {
                  return Promise.resolve(self[columnCache]);
                }
              }).nodeify(callback);
            };
            getter.__scope = this;
            Object.defineProperty(this, columnCache, {
              value: null,
              writable: true
            });
            Object.defineProperty(this, columnGetter, {
              value: getter
            });
          }
          return this[columnGetter];
        }
      });
    };

    ConnectionAssociation.prototype._applyAssociations = function() {
      this._pending_associations.forEach((function(_this) {
        return function(item) {
          var models, options, ref, ref1, target_model, this_model;
          this_model = item.this_model;
          options = item.options;
          if (typeof item.target_model_or_column === 'string') {
            if ((ref = item.options) != null ? ref.connection : void 0) {
              models = item.options.connection.models;
            } else {
              models = _this.models;
            }
            if ((ref1 = item.options) != null ? ref1.type : void 0) {
              target_model = item.options.type;
              options.as = item.target_model_or_column;
            } else if (item.type === 'belongsTo' || item.type === 'hasOne') {
              target_model = inflector.camelize(item.target_model_or_column);
            } else {
              target_model = inflector.classify(item.target_model_or_column);
            }
            if (!models[target_model]) {
              throw new Error("model " + target_model + " does not exist");
            }
            target_model = models[target_model];
          } else {
            target_model = item.target_model_or_column;
          }
          return _this['_' + item.type](this_model, target_model, options);
        };
      })(this));
      return this._pending_associations = [];
    };

    ConnectionAssociation.prototype.addAssociation = function(association) {
      this._pending_associations.push(association);
      return this._schema_changed = true;
    };

    ConnectionAssociation.prototype.getInconsistencies = function(callback) {
      return this._checkSchemaApplied().then((function(_this) {
        return function() {
          var promises, result;
          result = {};
          promises = Object.keys(_this.models).map(function(model) {
            var integrities, modelClass;
            modelClass = _this.models[model];
            integrities = modelClass._integrities.filter(function(integrity) {
              return integrity.type.substr(0, 7) === 'parent_';
            });
            if (integrities.length > 0) {
              return modelClass.select('').exec().then(function(records) {
                var ids, sub_promises;
                ids = records.map(function(record) {
                  return record.id;
                });
                sub_promises = integrities.map(function(integrity) {
                  var property, query;
                  query = integrity.child.select('');
                  query.where(_.zipObject([integrity.column], [
                    {
                      $not: {
                        $in: ids
                      }
                    }
                  ]));
                  property = integrity.child._schema[integrity.column];
                  if (!property.required) {
                    query.where(_.zipObject([integrity.column], [
                      {
                        $not: null
                      }
                    ]));
                  }
                  return query.exec().then(function(records) {
                    var array, name;
                    if (records.length > 0) {
                      array = result[name = integrity.child._name] || (result[name] = []);
                      [].push.apply(array, records.map(function(record) {
                        return record.id;
                      }));
                      return _.uniq(array);
                    }
                  });
                });
                return Promise.all(sub_promises);
              });
            } else {
              return Promise.resolve();
            }
          });
          return Promise.all(promises).then(function() {
            return Promise.resolve(result);
          });
        };
      })(this)).nodeify(callback);
    };

    ConnectionAssociation.prototype._fetchAssociatedBelongsTo = function(records, target_model, column, select, options) {
      var id, id_column, id_to_record_map, ids, query;
      id_column = column + '_id';
      if (Array.isArray(records)) {
        id_to_record_map = {};
        records.forEach(function(record) {
          var id;
          id = record[id_column];
          if (id) {
            (id_to_record_map[id] || (id_to_record_map[id] = [])).push(record);
          }
        });
        ids = Object.keys(id_to_record_map);
        query = target_model.where({
          id: ids
        });
        if (select) {
          query.select(select);
        }
        if (options.lean) {
          query.lean();
        }
        return query.exec().then(function(sub_records) {
          sub_records.forEach(function(sub_record) {
            return id_to_record_map[sub_record.id].forEach(function(record) {
              if (options.lean) {
                return record[column] = sub_record;
              } else {
                return Object.defineProperty(record, column, {
                  enumerable: true,
                  value: sub_record
                });
              }
            });
          });
          return records.forEach(function(record) {
            if (!record.hasOwnProperty(column)) {
              if (options.lean) {
                record[column] = null;
              } else {
                Object.defineProperty(record, column, {
                  enumerable: true,
                  value: null
                });
              }
            }
          });
        })["catch"](function() {});
      } else {
        id = records[id_column];
        if (id) {
          query = target_model.find(id);
          if (select) {
            query.select(select);
          }
          if (options.lean) {
            query.lean();
          }
          return query.exec().then(function(sub_record) {
            if (options.lean) {
              return records[column] = sub_record;
            } else {
              return Object.defineProperty(records, column, {
                enumerable: true,
                value: sub_record
              });
            }
          })["catch"](function(error) {
            if (error && error.message !== 'not found') {
              return Promise.reject(error);
            }
            if (!records.hasOwnProperty(column)) {
              if (options.lean) {
                return records[column] = null;
              } else {
                return Object.defineProperty(records, column, {
                  enumerable: true,
                  value: null
                });
              }
            }
          });
        } else if (!records.hasOwnProperty(column)) {
          if (options.lean) {
            records[column] = null;
          } else {
            Object.defineProperty(records, column, {
              enumerable: true,
              value: null
            });
          }
          return Promise.resolve();
        }
      }
    };

    ConnectionAssociation.prototype._fetchAssociatedHasMany = function(records, target_model, foreign_key, column, select, options) {
      var ids, query;
      if (Array.isArray(records)) {
        ids = records.map(function(record) {
          if (options.lean) {
            record[column] = [];
          } else {
            Object.defineProperty(record, column, {
              enumerable: true,
              value: []
            });
          }
          return record.id;
        });
        query = target_model.where(_.zipObject([foreign_key], [
          {
            $in: ids
          }
        ]));
        if (select) {
          query.select(select + ' ' + foreign_key);
        }
        if (options.lean) {
          query.lean();
        }
        return query.exec().then(function(sub_records) {
          return sub_records.forEach(function(sub_record) {
            return records.forEach(function(record) {
              if (record.id === sub_record[foreign_key]) {
                return record[column].push(sub_record);
              }
            });
          });
        })["catch"](function() {});
      } else {
        if (options.lean) {
          records[column] = [];
        } else {
          Object.defineProperty(records, column, {
            enumerable: true,
            value: []
          });
        }
        query = target_model.where(_.zipObject([foreign_key], [records.id]));
        if (select) {
          query.select(select + ' ' + foreign_key);
        }
        if (options.lean) {
          query.lean();
        }
        return query.exec().then(function(sub_records) {
          return sub_records.forEach(function(sub_record) {
            return records[column].push(sub_record);
          });
        })["catch"](function() {});
      }
    };

    ConnectionAssociation.prototype.fetchAssociated = function(records, column, select, options, callback) {
      if (typeof select === 'function') {
        callback = select;
        options = {};
        select = null;
      } else if (typeof options === 'function') {
        callback = options;
        options = {};
        if ((select != null) && typeof select === 'object') {
          options = select;
          select = null;
        }
      } else {
        if ((select != null) && typeof select === 'object') {
          options = select;
          select = null;
        } else if (options == null) {
          options = {};
        }
      }
      return this._checkSchemaApplied().then((function(_this) {
        return function() {
          var association, record, ref, ref1;
          record = Array.isArray(records) ? records[0] : records;
          if (!record) {
            return Promise.resolve();
          }
          if (options.target_model) {
            association = {
              type: options.type || 'belongsTo',
              target_model: options.target_model,
              foreign_key: options.foreign_key
            };
          } else if (options.model) {
            association = (ref = options.model._associations) != null ? ref[column] : void 0;
          } else {
            association = (ref1 = record.constructor._associations) != null ? ref1[column] : void 0;
          }
          if (!association) {
            return Promise.reject(new Error("unknown column '" + column + "'"));
          }
          if (association.type === 'belongsTo') {
            return _this._fetchAssociatedBelongsTo(records, association.target_model, column, select, options);
          } else if (association.type === 'hasMany') {
            return _this._fetchAssociatedHasMany(records, association.target_model, association.foreign_key, column, select, options);
          } else {
            return Promise.reject(new Error("unknown column '" + column + "'"));
          }
        };
      })(this)).nodeify(bindDomain(callback));
    };

    return ConnectionAssociation;

  })();

  module.exports = ConnectionAssociation;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var Connection, Model, Promise, addArgCompleterCoffee, addArgCompleterJS, addHistoryJS, addReplServer, coffee, evalCoffee, evalJS, fs, getCommandId, path, prettyErrorMessage, repl_coffee, repl_js, repl_servers, setupContext, util, vm;

  coffee = require('coffee-script');

  fs = require('fs');

  path = require('path');

  Promise = require('bluebird');

  repl_coffee = require('coffee-script/repl');

  repl_js = require('repl');

  vm = require('vm');

  util = require('util');

  Connection = require('../connection');

  Model = require('../model');

  Promise.config({
    cancellation: true
  });

  repl_servers = [];

  addReplServer = function(repl_server) {
    repl_server.on('exit', function() {
      var pos;
      pos = repl_servers.indexOf(repl_server);
      if (pos >= 0) {
        return repl_servers.splice(pos, 1);
      }
    });
    return repl_servers.push(repl_server);
  };

  setupContext = function(context, options) {
    var connection, key, model, modelClass, object, ref, ref1;
    context.Connection = Connection;
    context.Model = Model;
    context.connection = connection = Connection.defaultConnection;
    if (connection) {
      ref = connection.models;
      for (model in ref) {
        modelClass = ref[model];
        context[model] = modelClass;
      }
      connection.applySchemas();
    }
    Object.defineProperty(context.console, 'inspect_depth', {
      configurable: true,
      enumrable: true,
      get: function() {
        return options.inspect_depth;
      },
      set: function(value) {
        return options.inspect_depth = value;
      }
    });
    ref1 = exports["public"];
    for (key in ref1) {
      object = ref1[key];
      context[key] = object;
    }
    context.getTimestamp = function(object_id) {
      return new Date(parseInt(object_id.substr(0, 8), 16) * 1000);
    };
    context.console.measureTime = function(fn) {
      context.console.time('measureTime');
      return Promise.resolve(fn()).tap(function() {
        return context.console.timeEnd('measureTime');
      });
    };
  };

  exports["public"] = {};

  addArgCompleterCoffee = function(repl_server) {
    var node_completer, rli;
    rli = repl_server.rli;
    node_completer = rli.completer;
    return rli.completer = function(line, callback) {
      return node_completer(line, function(error, result) {
        var show_args;
        show_args = true;
        if (error || !result[0]) {
          show_args = false;
        } else if (result[0].length > 1) {
          show_args = false;
        } else if (result[0].length === 1 && result[0][0] !== result[1]) {
          show_args = false;
        } else if (!/^[A-Za-z0-9_.]+\s*$/.test(line)) {
          show_args = false;
        }
        if (!show_args) {
          return callback(error, result);
        }
        return repl_server["eval"](line, repl_server.context, 'repl', function(error, obj) {
          var argsMatch;
          if (typeof obj === 'function') {
            rli.output.write('\r\n');
            argsMatch = obj.toString().match(/^function\s*[^\(]*\(\s*([^\)]*)\)/m);
            rli.output.write((line.trim()) + " \u001b[35m" + argsMatch[1] + "\u001b[39m\r\n");
            rli._refreshLine();
          }
          return callback(error, result);
        });
      });
    };
  };

  prettyErrorMessage = coffee.helpers.prettyErrorMessage || function(e) {
    return e;
  };

  evalCoffee = function(cmd, context, filename, callback) {
    var assign_to, originalKeypressHandler, runner;
    cmd = cmd.replace(/\uFF00/g, '\n');
    cmd = cmd.replace(/^\(([\s\S]*)\n\)$/m, '$1');
    if (!cmd) {
      return callback(null);
    }
    if (/^\s*([a-zA-Z_$][0-9a-zA-Z_$]*)\s=/.test(cmd)) {
      assign_to = RegExp.$1;
    }
    originalKeypressHandler = this.rli.input._events.keypress[0];
    this.rli.input._events.keypress[0] = function(char, key) {
      if (key && key.ctrl && key.name === 'c') {
        runner.cancel();
      }
    };
    runner = Promise["try"](function() {
      var defer, js, result;
      if (/[, ]\$$/.test(cmd)) {
        defer = Promise.defer();
        context.$ = defer.callback;
      }
      js = coffee.compile(cmd, {
        filename: filename,
        bare: true
      });
      result = vm.runInContext(js, context, {
        filename: filename,
        displayErrors: false
      });
      if (defer) {
        delete context.$;
        return defer.promise;
      } else {
        return result;
      }
    });
    runner["finally"]((function(_this) {
      return function() {
        _this.rli.input._events.keypress[0] = originalKeypressHandler;
        if (runner.isCancelled()) {
          callback(prettyErrorMessage(new Promise.CancellationError(), filename, cmd, true));
        }
      };
    })(this)).then(function(result) {
      if (assign_to) {
        context[assign_to] = result;
      }
      callback(null, result);
    })["catch"](function(error) {
      callback(prettyErrorMessage(error, filename, cmd, true));
    });
  };

  exports.startCoffee = function(options) {
    var repl_server;
    options.inspect_depth || (options.inspect_depth = 2);
    if (options.socket) {
      options.socket.columns = 100;
    }
    repl_server = repl_coffee.start({
      input: options.socket || process.stdin,
      output: options.socket || process.stdout,
      prompt: 'cormo> ',
      historyFile: process.env.HOME ? path.join(process.env.HOME, '.cormo_history') : void 0,
      "eval": evalCoffee,
      writer: function(object) {
        return util.inspect(object, {
          colors: true,
          depth: options.inspect_depth
        });
      },
      terminal: true
    });
    addArgCompleterCoffee(repl_server);
    setupContext(repl_server.context, options);
    addReplServer(repl_server);
    return repl_server;
  };

  addHistoryJS = function(repl, filename, maxSize) {
    var buffer, fd, lastLine, readFd, size, stat;
    lastLine = null;
    try {
      stat = fs.statSync(filename);
      size = Math.min(maxSize, stat.size);
      readFd = fs.openSync(filename, 'r');
      buffer = new Buffer(size);
      fs.readSync(readFd, buffer, 0, size, stat.size - size);
      fs.close(readFd);
      repl.rli.history = buffer.toString().split('\n').reverse();
      if (stat.size > maxSize) {
        repl.rli.history.pop();
      }
      if (repl.rli.history[0] === '') {
        repl.rli.history.shift();
      }
      repl.rli.historyIndex = -1;
      lastLine = repl.rli.history[0];
    } catch (undefined) {}
    fd = fs.openSync(filename, 'a');
    repl.rli.addListener('line', function(code) {
      if (code && code.length && code !== '.history' && lastLine !== code) {
        fs.write(fd, code + "\n");
        return lastLine = code;
      }
    });
    repl.on('exit', function() {
      return fs.close(fd);
    });
    return repl.commands[getCommandId(repl, 'history')] = {
      help: 'Show command history',
      action: function() {
        repl.outputStream.write((repl.rli.history.slice(0).reverse().join('\n')) + "\n");
        return repl.displayPrompt();
      }
    };
  };

  getCommandId = function(repl, commandName) {
    var commandsHaveLeadingDot;
    commandsHaveLeadingDot = repl.commands['.help'] != null;
    if (commandsHaveLeadingDot) {
      return "." + commandName;
    } else {
      return commandName;
    }
  };

  evalJS = function(originalEval) {
    return function(cmd, context, filename, callback) {
      var assign_to, originalKeypressHandler, runner;
      if (/^\s*([a-zA-Z_$][0-9a-zA-Z_$]*)\s=/.test(cmd)) {
        assign_to = RegExp.$1;
      }
      originalKeypressHandler = this.rli.input._events.keypress;
      this.rli.input._events.keypress = function(char, key) {
        if (key && key.ctrl && key.name === 'c') {
          runner.cancel();
        }
      };
      runner = new Promise(function(resolve, reject) {
        return originalEval(cmd, context, filename, function(error, result) {
          if (error) {
            return reject(error);
          } else {
            return resolve(result);
          }
        });
      });
      runner["finally"]((function(_this) {
        return function() {
          _this.rli.input._events.keypress = originalKeypressHandler;
          if (runner.isCancelled()) {
            callback(new Promise.CancellationError());
          }
        };
      })(this)).then(function(result) {
        if (assign_to) {
          context[assign_to] = result;
        }
        callback(null, result);
      })["catch"](function(error) {
        callback(error);
      });
    };
  };

  addArgCompleterJS = function(repl_server) {
    var node_completer, rli;
    rli = repl_server.rli;
    node_completer = rli.completer;
    return rli.completer = function(line, callback) {
      line = line.replace(/\(\s*$/, '');
      return node_completer(line, function(error, result) {
        var show_args;
        show_args = true;
        if (error || !result[0]) {
          show_args = false;
        } else if (result[0].length > 1) {
          show_args = false;
        } else if (result[0].length === 1 && result[0][0] !== result[1]) {
          show_args = false;
        } else if (!/^[A-Za-z0-9_.]+\s*$/.test(line)) {
          show_args = false;
        }
        if (!show_args) {
          return callback(error, result);
        }
        return repl_server["eval"](line, repl_server.context, 'repl', function(error, obj) {
          var argsMatch;
          if (typeof obj === 'function') {
            rli.output.write('\r\n');
            argsMatch = obj.toString().match(/^function\s*[^\(]*\(\s*([^\)]*)\)/m);
            rli.output.write((line.trim()) + " \u001b[35m" + argsMatch[1] + "\u001b[39m\r\n");
            rli._refreshLine();
          }
          return callback(error, result);
        });
      });
    };
  };

  exports.startJS = function(options) {
    var historyFile, historyMaxInputSize, repl_server;
    options.inspect_depth || (options.inspect_depth = 2);
    if (options.socket) {
      options.socket.columns = 100;
    }
    repl_server = repl_js.start({
      input: options.socket || process.stdin,
      output: options.socket || process.stdout,
      prompt: 'cormo> ',
      writer: function(object) {
        return util.inspect(object, {
          colors: true,
          depth: options.inspect_depth
        });
      },
      terminal: true
    });
    repl_server["eval"] = evalJS(repl_server["eval"]);
    if (process.env.HOME) {
      historyFile = path.join(process.env.HOME, '.cormo_history_js');
    }
    historyMaxInputSize = 10240;
    if (historyFile) {
      addHistoryJS(repl_server, historyFile, historyMaxInputSize);
    }
    addArgCompleterJS(repl_server);
    setupContext(repl_server.context, options);
    addReplServer(repl_server);
    return repl_server;
  };

  exports.resetupContext = function() {
    var i, key, len, object, repl_server, results;
    results = [];
    for (i = 0, len = repl_servers.length; i < len; i++) {
      repl_server = repl_servers[i];
      results.push((function() {
        var ref, results1;
        ref = exports["public"];
        results1 = [];
        for (key in ref) {
          object = ref[key];
          results1.push(repl_server.context[key] = object);
        }
        return results1;
      })());
    }
    return results;
  };

}).call(this);
